#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Motor,  mtr_S1_C1_1,     mLTrack,       tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     mRTrack,       tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     mBlockAr,      tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     mBridgeAr,     tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     mDispAr,       tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     mRGLiftAr,     tmotorNormal, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    sRGTeeth,             tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    sBatonCup,            tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    sRoDisp,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    sMouDisp,             tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This is necessary so that waitForStart() communication from the Samantha Field
// Control is received properly.  Otherwise, waitForStart() is undefined.
#include "JoystickDriver.c"

/************************
* Code for Autonomous
*          Period
* By Bridger Howell
* Team 4309
*************************
* Motors-----------------
*************************
* mLTrack (USE)
*      Controls left side
*      of the track
* mRTrack (USE)
*      Controls right
*      side of the track
* mBlockAr (USE)
*      Controls the block
*      autonomous arm
* mBridgeAr (USE)
*      Controls bridge
*      lowering arm
* mDispAr (?)*
*      Controls the disp-
*      ensing arm
* mRGLiftAr (?)
*      Controls the roll-
*      ing goal lifting
*      arm
*************************
* Servos-----------------
*************************
* sRGTeeth (?)
*      Controls the teeth
*      for mRGLiftAr
* sBatonCup (USE)
*      Controls the baton
*      cup w/ mBlockAr
* sRoDisp (?)
*      Controls the disp-
*      enser w/ mDispAr
* sMouDisp (?)
*      Controls the disp-
*      ensing mouth w/get
*      mDispAr
*************************/

//Times for movement
const int FOOT_TIME = 200;
const int FULL_TURN_TIME = 500;

//Time for RG Arm to drop [TWEAK]
const int RGARM_DROP_TIME = 3000;

//Time for RG Arm to lift [TWEAK]
const int RGARM_LIFT_TIME = 1000;

//Time for Bridge Arm to drop [TWEAK]
const int BRARM_DROP_TIME = 1000;

//Time for Autonomous Block Arm in milliseconds [TWEAK]
const int BA_TIME = 5000;

//Power for Motors [TWEAK]
const int BLOCK_ARM_POWER = 100;
const int RGLIFT_ARM_POWER = 100;
const int TRACK_POWER = 100;
const int BRARM_POWER = 100;

//Servo Positions [TWEAK]
const int DISPENSER_MIN = 0;
const int DISPENSER_MAX = 140;
const int MOUTH_MIN = 0;
const int MOUTH_MAX = 140;
const int RGTEETH_MIN = 0;
const int RGTEETH_MAX = 140;
const int BCUP_MIN = 0;
const int BCUP_MAX = 140;

void toggleDispenser();
void dropDispenser();
void raiseDispenser();
task DispenseTask();

void toggleMouth();
void dropMouth();
void raiseMouth();
task MouthTask();

void toggleBlockArm();
void stopBlockArm();
task BlockTask();

void toggleRGLift();
void abortRGLift();
task RGLiftTask();

int calcMove(float dist);
void move(float dist);
void stopMove();
task MoveTask();

int calcTurn(float deg);
void turn(float deg);
void stopTurn();
task TurnTask();
bool moving();

void toggleBrArm();
void stopBrArm();
task BridgeTask();

void toggleBatonCup();
void openBatonCup();
void closeBatonCup();
task BatonCupTask();

void initializeRobot()
{
    //StartTask(DispenseTask);
    //StartTask(MouthTask);
    StartTask(BlockTask);
    //StartTask(RGLiftTask);
    StartTask(MoveTask);
    StartTask(TurnTask);
    StartTask(BridgeTask);
    StartTask(BatonCupTask);
}

//Autonomous code start
task main()
{
    initializeRobot();
    waitForStart();
}

typedef enum
{
    STOP_MOVE,
    MOVE_FOREWARD,
    FOREWARD,
    MOVE_BACKWARD,
    BACKWARD,
} moveState;

moveState mState = STOP_MOVE;

int moveTime;

int calcMove(float dist)
{
    int time;

    //make time based on FOOT_TIME and convert to milliseconds
    time = dist * FOOT_TIME;
    time *= 1000;

    wait1Msec(time);
    return time;
}

void move(float dist)
{
    if (!moving())
    {
        moveTime = calcMove(dist);
        if (dist < 0)
        {
            moveTime = abs(moveTime);
            mState = MOVE_BACKWARD;
        }
        if (dist > 0)
            mState = MOVE_FOREWARD;
    }
}

void stopMove()
{
    mState = STOP_MOVE;
}

task MoveTask()
{
    while (true)
    {
        switch (mState)
        {
        case STOP_MOVE:
            motor[mLTrack] = 0;
            motor[mRTrack] = 0;
            break;
        case MOVE_FOREWARD:
            time1[T3] = 0;
            motor[mLTrack] = TRACK_POWER;
            motor[mRTrack] = TRACK_POWER;
            mState = FOREWARD;
            break;
        case FOREWARD:
            if (time1[T3] > moveTime)
            {
                mState = STOP_MOVE;
            }
            break;
        case MOVE_BACKWARD:
            time1[T3] = 0;
            motor[mLTrack] = -TRACK_POWER;
            motor[mRTrack] = -TRACK_POWER;
            mState = BACKWARD;
            break;
        case BACKWARD:
            if (time1[T3] > moveTime)
            {
                mState = STOP_MOVE;
            }
            break;
        }
    }
}

typedef enum
{
    STOP_TURN,
    TURN_CW,
    CW,
    TURN_CCW,
    CCW,
} turnState;

turnState tState = STOP_TURN;

int turnTime;

int calcTurn(float deg)
{
    float time;
    //convert degrees to be more useful
    if (abs(deg) >= 180)
    {
        if (deg < 0)
            deg += 360;
        if (deg > 0)
            deg -= 360;
    }
    time = (deg / 360) * FULL_TURN_TIME * 1000;

    return (int)time;
}

void turn(float deg)
{
    if (!moving())
    {
        turnTime = calcTurn(deg);
        if (turnTime > 0)
        {
            tState = TURN_CW;
        }
        if (turnTime < 0)
        {
            turnTime = abs(turnTime);
            tState = TURN_CCW;
        }
    }
}

void stopTurn()
{
    tState = STOP_TURN;
}

task TurnTask()
{
    while (true)
    {
        switch (tState)
        {
        case STOP_TURN:
            motor[mLTrack] = 0;
            motor[mRTrack] = 0;
            break;
        case TURN_CW:
            time1[T3] = 0;
            motor[mLTrack] = TRACK_POWER;
            motor[mRTrack] = -TRACK_POWER;
            tState = CW;
            break;
        case CW:
            if (time1[T3] > turnTime)
            {
                tState = STOP_TURN;
            }
            break;
        case TURN_CCW:
            time1[T3] = 0;
            motor[mLTrack] = -TRACK_POWER;
            motor[mRTrack] = TRACK_POWER;
            tState = CCW;
            break;
        case CCW:
            if (time1[T3] > turnTime)
            {
                tState = STOP_TURN;
            }
            break;
        }
    }
}

bool moving()
{
    if (tState == STOP_TURN && mState == STOP_MOVE)
        return false;
    else
        return true;
}

typedef enum
{
    STOP_BARM,
    MOVE_FOREWARD,
    FOREWARD,
    MOVE_BACKWARD,
    BACKWARD,
} bridgeState;

bridgeState brState = STOP_BARM;
bridgeState lastDir = BACKWARD;

void toggleBrArm()
{
    if (lastDir == BACKWARD)
        brState = MOVE_FOREWARD;
    else if (lastDir == FOREWARD)
        brState = MOVE_BACKWARD;
}

void stopBrArm()
{
    brState = STOP_BARM;
}

task BridgeTask()
{
    while (true)
    {
        switch (brState)
        {
        case STOP_BARM:
            motor[mBridgeAr] = 0;
            break;
        case MOVE_FOREWARD:
            time1[T4] = 0;
            motor[mBridgeAr] = BRARM_POWER;
            brState = FOREWARD;
            lastDir = FOREWARD;
            break;
        case FOREWARD:
            if (time1[T1] > BRARM_DROP_TIME)
                brState = STOP_BARM;
            break;
        case MOVE_BACKWARD:
            time1[T4] = 0;
            motor[mBridgeAr] = -BRARM_POWER;
            brState = BACKWARD;
            lastDir = BACKWARD;
            break;
        case BACKWARD:
            if (time1[T1] > BRARM_DROP_TIME)
                brState = STOP_BARM;
            break;
        }
    }
}

bool cupOpen = false;
void toggleBatonCup()
{
    cupOpen = !cupOpen;
}

void openBatonCup()
{
    cupOpen = true;
}

void closeBatonCup()
{
    cupOpen = false;
}

task BatonCupTask()
{
    while (true)
    {
        if (cupOpen)
            servo[sBatonCup] = BCUP_MIN;
        else
            servo[sBatonCup] = BCUP_MAX;
        wait1Msec(10);
    }
}

bool dispDown = true;
void toggleDispenser()
{
    dispDown = !dispDown;
}

void dropDispenser()
{
    dispDown = true;
}

void raiseDispenser()
{
    dispDown = false;
}

task DispenseTask()
{
    while (true)
    {
        if (dispDown)
            servo[sRoDisp] = DISPENSER_MIN;
        else
            servo[sRoDisp] = DISPENSER_MAX;
        wait1Msec(10);
    }
}

bool mouthDown = true;
void toggleMouth()
{
    mouthDown = !mouthDown;
}

void dropMouth()
{
    mouthDown = true;
}

void raiseMouth()
{
    mouthDown = false;
}

task MouthTask()
{
    while (true)
    {
        if (mouthDown)
            servo[sMouDisp] = MOUTH_MIN;
        else
            servo[sMouDisp] = MOUTH_MAX;
        wait1Msec(10);
    }
}

typedef enum
{
    NOT_MOVING,
    MOVE_LEFT,
    MOVING_LEFT,
    MOVE_RIGHT,
    MOVING_RIGHT
} blockState;

blockState bState = NOT_MOVING;
blockState lastDirection = MOVE_LEFT;

void toggleBlockArm()
{
    if (lastDirection == MOVE_LEFT)
        bState = MOVE_RIGHT;
    else
        bState = MOVE_LEFT;
}

void stopBlockArm()
{
    bState = NOT_MOVING;
}

task BlockTask()
{
    //XXX Keep track of how long the movement has progressed
    while (true)
    {
        switch (bState)
        {
        case NOT_MOVING:
            motor[mBlockAr] = 0;
            break;
        case MOVE_LEFT:
            time1[T1] = 0;
            motor[mBlockAr] = BLOCK_ARM_POWER;
            bState = MOVING_LEFT;
            lastDirection = MOVE_LEFT;
            break;
        case MOVING_LEFT:
            if (time1[T1] > BA_TIME)
                bState = NOT_MOVING;
            break;
        case MOVE_RIGHT:
            time1[T1] = 0;
            motor[mBlockAr] = -BLOCK_ARM_POWER;
            bState = MOVING_RIGHT;
            lastDirection = MOVE_RIGHT;
            break;
        case MOVING_RIGHT:
            if (time1[T1] > BA_TIME)
                bState = NOT_MOVING;
            break;
        default:
            nxtDisplayString(3, "BLOCK ARM ERROR %d", bState);
            break;
        }
        wait1Msec(10);
    }
}

typedef enum
{
    PARKED,
    DROP_ARM,
    DROPPING_ARM,
    RAISE_ARM,
    RAISING_ARM,
    READY,
    START_CAPTURE,
    LOWERING_TEETH,
    LIFT_RG,
    LIFTING_RG,
    LOADED,
    UNLOAD,
    LOWERING_RG,
    RAISING_TEETH
} liftState;

liftState lState = READY;

void toggleRGLift()
{
    switch (lState)
    {
    case PARKED:
        lState = DROP_ARM;
        break;
    case DROP_ARM:
    case DROPPING_ARM:
    case RAISE_ARM:
    case RAISING_ARM:
        //Ignore
        break;
    case READY:
        lState = START_CAPTURE;
        break;
    case START_CAPTURE:
    case LOWERING_TEETH:
    case LIFT_RG:
    case LIFTING_RG:
        //Ignore
        break;
    case LOADED:
        lState = UNLOAD;
        break;
    case UNLOAD:
    case LOWERING_RG:
    case RAISING_TEETH:
    default:
        //Ignore
        break;
    }
}

void abortRGLift()
{
    switch (lState)
    {
    case PARKED:
    case RAISE_ARM:
    case RAISING_ARM:
        //Ignore
        break;
    case DROP_ARM:
    case DROPPING_ARM:
    case READY:
        lState = RAISE_ARM;
        break;
    case START_CAPTURE:
    case LOWERING_TEETH:
        lState = RAISING_TEETH;
        break;
    case LIFT_RG:
    case LIFTING_RG:
    case LOADED:
        lState = UNLOAD;
        break;
    case UNLOAD:
    case LOWERING_RG:
    case RAISING_TEETH:
    default:
        //Ignore
        break;
    }
}

task RGLiftTask()
{
    while (true)
    {
        switch (lState)
        {
        case PARKED:
            servo[sRGTeeth] = RGTEETH_MIN;
            //Assume the RG Arm is up
            break;
        case DROP_ARM:
            time1[T2] = 0;
            motor[mRGLiftAr] = RGLIFT_ARM_POWER;
            lState = DROPPING_ARM;
            break;
        case DROPPING_ARM:
            if (time1[T2] > RGARM_DROP_TIME)
            {
                motor[mRGLiftAr] = 0;
                lState = READY;
            }
            break;
        case RAISE_ARM:
            time1[T2] = 0;
            motor[mRGLiftAr] = -RGLIFT_ARM_POWER;
            lState = RAISING_ARM;
            break;
        case RAISING_ARM:
            if (time1[T2] > RGARM_DROP_TIME)
            {
                motor[mRGLiftAr] = 0;
                lState = PARKED;
            }
            break;
        case READY:
            servo[sRGTeeth] = RGTEETH_MIN;
            //Assume the RG Arm is down
            break;
        case START_CAPTURE:
            servo[sRGTeeth] = RGTEETH_MAX;
            lState = LOWERING_TEETH;
            break;
        case LOWERING_TEETH:
            servo[sRGTeeth] = RGTEETH_MAX;
            if (ServoValue[sRGTeeth] == RGTEETH_MAX)
                lState = LIFT_RG;
            break;
        case LIFT_RG:
            servo[sRGTeeth] = RGTEETH_MAX;
            time1[T2] = 0;
            motor[mRGLiftAr] = -RGLIFT_ARM_POWER;
            lState = LIFTING_RG;
            break;
        case LIFTING_RG:
            servo[sRGTeeth] = RGTEETH_MAX;
            if (time1[T2] > RGARM_LIFT_TIME)
            {
                motor[mRGLiftAr] = 0;
                lState = LOADED;
                time1[T2] = 0;
            }
            break;
        case LOADED:
            servo[sRGTeeth] = RGTEETH_MAX;
            if (time1[T2] > 500)
            {
                time1[T2] = 0;
                motor[mRGLiftAr] = -RGLIFT_ARM_POWER;
            }
            else if (time1[T2] > 100)
            {
                motor[mRGLiftAr] = 0;
            }
            break;
        case UNLOAD:
            time1[T2] = 0;
            motor[mRGLiftAr] = RGLIFT_ARM_POWER;
            lState = LOWERING_RG;
            break;
        case LOWERING_RG:
            if (time1[T2] > RGARM_LIFT_TIME)
            {
                motor[mRGLiftAr] = 0;
                servo[sRGTeeth] = RGTEETH_MIN;
                lState = RAISING_TEETH;
            }
            break;
        case RAISING_TEETH:
            if (ServoValue[sRGTeeth] == RGTEETH_MIN)
            {
                lState = READY;
            }
            break;
        default:
            nxtDisplayString(3, "RG ARM ERROR # %d", lState);
            break;
        }
        wait1Msec(10);
    }
}
