#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Motor,  motorA,          mDispWristL,   tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorB,          mDispWristR,   tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     mLTrack,       tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     mRTrack,       tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     mBatonArm,     tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     mBridgeArm,    tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     mDispArm,      tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     mRGLiftArm,    tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    ,                     tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    sBatonCup,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    sRGTeethL,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_5,    sRGTeethR,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    sDispCup,             tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
	Bridger Howell
	Team 4309
	AutonomousKNv1.c
*/

#include "JoystickDriver.c"

const int BATON_TEST = 0;
const int TURN_TEST = 1;
const int MOVE_TEST = 2;

const int AUTO_ROUTINE = MOVE_TEST;

// The arm motors overshoot a bit, so until we write useful PID
// controllers for them, we consider 'zero' when moving back to a
// position anything less than this.
const int ARM_POS_ZERO_SLOP = 25;

//
// Baton/Blocking Arm constants (right arm)
//
const int BATON_ARM_DEPLOYED_POS = 720;

// Power to the baton arm
const int BATON_ARM_MOVE_POWER = 40;

// Baton dispenser open/close
const int BATON_DISPENSER_CLOSE = 244;
const int BATON_DISPENSER_OPEN = 104;

//
// Bridge Arm constants (left arm)
//

// How far to move the arm all the way out
const int BRIDGE_ARM_DEPLOYED_POS = 1200;

// Power to the bridge arm
const int BRIDGE_ARM_MOVE_POWER = 40;

//
// Dispenser Constants (front/center arm)
//

// How far to move the arm all the way up
const int DISPENSER_ARM_HIGHEST_POS = 3500;

// Power to the dispenser arm
const int DISPENSER_ARM_MOVE_POWER = 30;
const int DISPENSER_ARM_PRESET_MOVE_POWER = 10;

// The three preset heights for the dispenser arm
const int DISPENSER_ARM_HIGH_PRESET_POS = 3000;
const int DISPENSER_ARM_MED_PRESET_POS = 2000;
const int DISPENSER_ARM_LOW_PRESET_POS = 1000;

// The maximum amount we can 'tweak' the preset heights.
const int DISPENSER_ARM_TWEAK_LIMIT =
    (DISPENSER_ARM_HIGH_PRESET_POS - DISPENSER_ARM_MED_PRESET_POS) / 2;

// How close does the arm need to be to the setpoint to consider it
// 'good enough'?
const int DISPENSER_ARM_PRESET_SLOP = 20;

// The dispenser cup's center position at start
const int DISPENSER_CUP_CENTER_POS = 128;

// Dispenser arm 'wrist'
const int DISPENSER_WRIST_DEPLOYED_POS = 90;

// Power to the dispenser wrist
const int DISPENSER_WRIST_MOVE_DOWN_POWER = 70;
const int DISPENSER_WRIST_MOVE_UP_POWER = -20;

//
// Rolling Goal Arm constants (rear/center arm)
//

// 2 full rotations down from park (~90 degrees)!
const int RG_ARM_DROP_POS = 1440 * 2;

// How far to move up to 'lift' the rolling goal
const int RG_ARM_LIFT_AMT = 240;
const int RG_ARM_LIFT_POS = RG_ARM_DROP_POS - RG_ARM_LIFT_AMT;

// We don't need much power to move it up/down, but use it all for
// lifting the goal
const int RG_ARM_MOVE_POWER = 40;
const int RG_ARM_LIFT_POWER = 100;

// The maximum amount of time we'll use to 'lift' the goal at full
// power.  If we can't get there, this avoids burning up the motors.
const int RG_ARM_MAX_LIFT_TIME = 5 * 1000;

// The servos that control the Rolling Goal are the 'teeth' the control
// the goal at the top
const int RG_TEETH_LEFT_UP = 220;
const int RG_TEETH_LEFT_DOWN = 40;
const int RG_TEETH_RIGHT_UP = 20;
const int RG_TEETH_RIGHT_DOWN = 200;



//Constants to be Tweaked
const int TRACK_ENC_LENGTH = 2000;
const float FULL_TRACK_MOVE_DIST = 38.75/12;
const float DOUBLE_TRACK_TURN_DEG = 45;

task MoveTask();

void toggleBatonArm();
task BatonArmTask();

void toggleBatonDrop();
void closeBatonDrop();
void openBatonDrop();

task BatonDropTask();

int calculateTetrixPower(int power, long remainDist);
void autoRoutine();

void turn(int deg);
void turnWait(int deg);
void move(float dist);
void moveWait(float dist);
void setSpeed(int speed);

void initializeRobot()
{
	motor[mLTrack] = 0;
	motor[mRTrack] = 0;
	nMotorEncoder[mLTrack] = 0;
	nMotorEncoder[mRTrack] = 0;
	StartTask(MoveTask);
	StartTask(BatonArmTask);
	StartTask(BatonDropTask);
}

task main()
{
	initializeRobot();
	waitForStart();
	autoRoutine();
}

void autoRoutine()
{
    switch(AUTO_ROUTINE)
    {
        case BATON_TEST:
            toggleBatonArm();
		    wait1Msec(4000);
		    openBatonDrop();
		    wait1Msec(2000);
		    closeBatonDrop();
		    wait1Msec(2000);
		    toggleBatonArm();
		    wait1Msec(3000);
		    break;
		case TURN_TEST:
		    setSpeed(50);
		    turn(45);
		    wait1Msec(5000);
		    turn(-45);
		    wait1Msec(5000);
		    break;
		case MOVE_TEST:
		    setSpeed(50);
		    move(2);
		    wait1Msec(4000);
    }
}

typedef enum
{
	TRACK_STOP,
	TRACK_MOVING,
	TRACK_TURNING,
	TRACK_FORWARD,
	TRACK_BACKWARD,
	TRACK_LEFT,
	TRACK_RIGHT,

} TrackState;

TrackState trState = TRACK_STOP;

int distance = 0;
int degrees = 0;
int power = 30;

void setSpeed(int speed)
{
    power = speed;
}

float calcMoveEnc(float dist)
{
	float encDist;
	encDist = dist;
	encDist*=TRACK_ENC_LENGTH;
	encDist/=FULL_TRACK_MOVE_DIST;
	return encDist;
}

void move(float dist)
{
    if(dist == 0)
		return;

	if(trState != TRACK_STOP)
	{
	    nxtDisplayBigString(0, "Bad movement, still moving");
	    return;
	}

	distance = (int)calcMoveEnc(dist);

	if(distance > 0)
		trState = TRACK_FORWARD;
	else
		trState = TRACK_BACKWARD;
}

void moveWait(float dist)
{
    move(dist);
    while(trState!=TRACK_STOP)
        EndTimeSlice();
}

float calcTurnEnc(int deg)
{
    float degree = deg;
    if(degree <= -180)
        degree+=360;
    if(degree > 180)
        degree-=360;
    degree*=TRACK_ENC_LENGTH;
    degree/=DOUBLE_TRACK_TURN_DEG;
    return degree;
}

void turn(int deg)
{
    if(deg == 0)
        return;
    if(trState != TRACK_STOP)
    {
        nxtDisplayBigString(0, "Bad movement, still moving");
	    return;
	}

    degrees = (int)calcTurnEnc(deg);

    if(degrees > 0)
        trState = TRACK_RIGHT;
    else
        trState = TRACK_LEFT;
}

void turnWait(int deg)
{
    turn(deg);
    while(trState!=TRACK_STOP)
        EndTimeSlice();
}

task MoveTask()
{
	while(true)
	{
	    int rPos = abs(nMotorEncoder[mRTrack]);
	    int lPos = abs(nMotorEncoder[mLTrack]);
	    degrees = abs(degrees);
	    nxtDisplayString(1,"%d / %d", distance, trState);
	    nxtDisplayString(2,"%d - %d", lPos, rPos);
		switch(trState)
		{
			case TRACK_STOP:
				motor[mLTrack] = 0;
				motor[mRTrack] = 0;
				break;

			case TRACK_MOVING:
                if(lPos >= distance)
                    motor[mLTrack] = 0;
                if(rPos >= distance)
                    motor[mRTrack] = 0;

                if(lPos >= distance && rPos >= distance)
                    trState = TRACK_STOP;
				break;

			case TRACK_TURNING:
                if(lPos >= degrees)
                    motor[mLTrack] = 0;
                if(rPos >= degrees)
                    motor[mRTrack] = 0;

                if(lPos >= degrees && rPos >= degrees)
                    trState = TRACK_STOP;
                break;

		    case TRACK_LEFT:
		        nMotorEncoder[mLTrack] = 0;
                nMotorEncoder[mRTrack] = 0;
			    motor[mLTrack] = -power;
			    motor[mRTrack] = power;
			    trState = TRACK_TURNING;
			    break;

			case TRACK_RIGHT:
		        nMotorEncoder[mLTrack] = 0;
                nMotorEncoder[mRTrack] = 0;
			    motor[mLTrack] = power;
			    motor[mRTrack] = -power;
			    trState = TRACK_TURNING;
			    break;

			case TRACK_FORWARD:
			    nMotorEncoder[mLTrack] = 0;
			    nMotorEncoder[mRTrack] = 0;
				motor[mLTrack] = power;
				motor[mRTrack] = power;
				trState = TRACK_MOVING;
				break;

			case TRACK_BACKWARD:
			    nMotorEncoder[mLTrack] = 0;
			    nMotorEncoder[mRTrack] = 0;
				motor[mLTrack] = -power;
				motor[mRTrack] = -power;
				trState = TRACK_MOVING;
				break;
		}
	}
}

typedef enum {
    BATON_PARKED,
    MOVE_OUT,
    BATON_DEPLOYED,
    MOVE_IN
} batonState;

batonState bState = BATON_PARKED;

void toggleBatonArm()
{
    switch (bState) {
    case BATON_PARKED:
    case MOVE_IN:
        bState = MOVE_OUT;
        break;

    case MOVE_OUT:
    case BATON_DEPLOYED:
        bState = MOVE_IN;
        break;
    }
}

task BatonArmTask()
{
    // Turn off the motor and reset the encoder.  Note, we assume the
    // arm is tucked into the robot at program start.
    motor[mBatonArm] = 0;
    nMotorEncoder[mBatonArm] = 0;
    while (true) {
        long armPos = nMotorEncoder[mBatonArm];
        long targetPos = -1;
        switch (bState) {
        case MOVE_OUT:
            if (armPos >= BATON_ARM_DEPLOYED_POS)
                bState = BATON_DEPLOYED;
            // fall through
        case BATON_DEPLOYED:
            targetPos = BATON_ARM_DEPLOYED_POS;
            break;

        case MOVE_IN:
            if (armPos <= ARM_POS_ZERO_SLOP)
                bState = BATON_PARKED;
            // fall through
        case BATON_PARKED:
            targetPos = 0;
            break;

        default:
            nxtDisplayString(3, "BATON ARM ERROR %d", bState);
            break;
        }

        // Do we need to move the arm?
        if (targetPos >= 0) {
            // No need to do anything if we're 'close enough' to the
            // target.
            if (abs(armPos - targetPos) <= ARM_POS_ZERO_SLOP) {
                // Turn off the motor
                motor[mBatonArm] = 0;
            } else {
                // Gotta move to get there!
                int armPower = calculateTetrixPower(
                    BATON_ARM_MOVE_POWER, abs(targetPos - armPos));
                // XXX - Check if these are correct for this motor?
                if (targetPos > armPos)
                    motor[mBatonArm] = armPower;
                else
                    motor[mBatonArm] = -armPower;
            }
        }
        EndTimeSlice();
    }
}

bool batonDropClosed = true;
void toggleBatonDrop()
{
    batonDropClosed = !batonDropClosed;
}

void closeBatonDrop()
{
    batonDropClosed = true;
}

void openBatonDrop()
{
    batonDropClosed = false;
}

task BatonDropTask()
{
    while (true) {
        if (batonDropClosed)
            servo[sBatonCup] = BATON_DISPENSER_CLOSE;
        else
            servo[sBatonCup] = BATON_DISPENSER_OPEN;

        // Give the other threads a chance to run.
        EndTimeSlice();
    }
}


const int MIN_POWER = 20;
const int SLOW_START_DIST = 720;

int calculateTetrixPower(int power, long remainDist)
{
    // We only reduce power if the calculations if the request is for more than
    // MIN_POWER and that we have a 'bit of distance' to go.  If we're close, we need
    // full power (in case we're stopped), so we only slow down as we start to get
    // close and then speed back up.
    if (abs(power) < MIN_POWER || remainDist > SLOW_START_DIST)
        return power;

    // Linear reduction in power based on how far we have remaining.
    power -= (int)((float)power / 2.0 *
                   (((float)SLOW_START_DIST - (float)remainDist) /
                    (float)SLOW_START_DIST));

    // Limit ourself to at least MIN_POWER.
    if (abs(power) < MIN_POWER) {
        if (power < 0)
            power = -MIN_POWER;
        else
            power = MIN_POWER;
    }
    return power;
}
