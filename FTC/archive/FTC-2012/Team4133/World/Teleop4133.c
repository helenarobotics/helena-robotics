#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C2_1,     ballMotor,     tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     basketTurnMotor, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     leftLifterMotor, tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     rightLifterMotor, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     DriveLeft,     tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_2,     DriveRight,    tmotorNormal, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    flagServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    rightGripperServo,    tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    leftGripperServo,     tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    TrightGripperServo,   tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    TleftGripperServo,    tServoStandard)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "ImprovedJoystick.c"  //Include file to "handle" the Bluetooth messages.

int leftGripperPosition;
int rightGripperPosition;
int TleftGripperPosition;
int TrightGripperPosition;
int AllLeftGripperPosition;
int AllRightGripperPosition;

string nudgeStatus;


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void initializeRobot()
  {
    //initialize display to show teleop is ready
    eraseDisplay();
    nxtDisplayCenteredTextLine(1, "TeleOp");
    nxtDisplayCenteredTextLine(7, "READY");

    //set grippers to default position
    AllLeftGripperPosition  = ServoValue[leftGripperServo];
    AllRightGripperPosition = ServoValue[rightGripperServo];

    leftGripperPosition   = AllLeftGripperPosition;
    rightGripperPosition  = AllRightGripperPosition;
    TleftGripperPosition  = AllLeftGripperPosition;
    TrightGripperPosition = AllRightGripperPosition;

    servo[leftGripperServo]   = leftGripperPosition;
    servo[TleftGripperServo]  = TleftGripperPosition;
    servo[rightGripperServo]  = rightGripperPosition;
    servo[TrightGripperServo] = TrightGripperPosition;

    //make sure flag is down
    servo[flagServo] = 0;

    //initialize sound on NXT
    nVolume = 4;
    ClearSounds();

    //initialize lifter nudge to be ready for command
    nudgeStatus = "waiting";
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                               Power
//
// Provides an exponential function for floating point numbers
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
float Power(float num, int exp)
  {
    // require positive integer for the exponent
    if (exp <= 0)
      {
        return 0;
      }

    float result = num;

    for (int i = 1; i < exp; i++)
      {
        result *= num;
      }

    return result;
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                               adjJoystickMotorPowerExp
//
// As the range of values for the joysticks are -128 to 127 and the range of power settings for the
// motors are -100 to 100. We must adjust the joystick values to be within the motor values using
// an exponential curve. This will allow the best control over our lifter.
//
// Also, since the joysticks do not always center exactly at position 0 when released, we use a
// thresh hold value to provide a small range of values that all equate to no movement
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
int adjJoystickMotorPowerExp(int i_joystickReading, float i_rangeMax, int i_threshHold)
  {
    const float vSensitivity = 0.7;
    const int   vExp         = 3;

    int vMotorPower = i_joystickReading;

    //Compare to the thresh hold to account for variations in calibration
    if (abs(vMotorPower) < i_threshHold)
      {
        vMotorPower = 0;
      }
    else
      {
        //The value is outside the thresh hold. We now need to adjust to the
        //desired range. To do this first we convert the value to a floating
        //point number between -1 and 1
        float vFloatPower = vMotorPower / 127.0;

        //Next we apply our exponential formula
        float result = vSensitivity * Power(vFloatPower, vExp) +
                       (1 - vSensitivity) * vFloatPower;

        //Finally we adjust for our range
        vMotorPower = (int)(i_rangeMax * result);
      }

    return vMotorPower;
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                               adjJoystickMotorPower
//
// As the range of values for the joysticks are -128 to 127 and the range of power settings for the
// motors are -100 to 100. We must adjust the joystick values to be within the motor values. This
// will allow the best driving experience for the robot.
//
// Also, since the joysticks do not always center exactly at position 0 when released, we use a
// thresh hold value to provide a small range of values that all equate to no movement
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
int adjJoystickMotorPower(int i_joystickReading, int i_rangeMax, int i_threshHold)
  {
    int vMotorPower = i_joystickReading;

    //Compare to the thresh hold to account for variations in calibration
    if (abs(vMotorPower) < i_threshHold)
      {
        vMotorPower = 0;
      }
    else
      {
        //The value is outside the thresh hold. We now need to adjust to the
        //desired range. To do this first we need to subtract our thresh hold value
        vMotorPower = vMotorPower - i_threshHold;

        //Next we adjust for our range
        vMotorPower = floor((vMotorPower * i_rangeMax) / (127 - i_threshHold));
      }

    return vMotorPower;
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Max
//
// This procedure returns the largest of two values
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
int max(int val1, int val2)
  {
    if (val1 > val2)
      {
        return val1;
      }
    else
      {
        return val2;
      }
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Min
//
// This procedure returns the smallest of two values
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
int min(int val1, int val2)
  {
    if (val1 < val2)
      {
        return val1;
      }
    else
      {
        return val2;
      }
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Movement Control
//
// This procedure is responsible for translating the joystick readings into motor power for the
// motors responsible for moving the robot
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void movementControl()
  {
    int DriveLeftPower;
    int DriveRightPower;
    int maxMotorPower;

    //set maximum speed
    if (joy1Btn(5))
      {
        maxMotorPower = 100;
      }
    else if (joy1Btn(7))
      {
        maxMotorPower = 20;
      }
    else
      {
        maxMotorPower = 60;
      }

    //get joystick reading translate to power setting
    DriveLeftPower  = adjJoystickMotorPower(joystick.joy1_y1, maxMotorPower, 5);
    DriveRightPower = adjJoystickMotorPower(joystick.joy1_y2, maxMotorPower, 5);

    //set power for each motor
    motor[DriveRight] = DriveRightPower;
    motor[DriveLeft]  = DriveLeftPower;
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Ball Control
//
// This procedure is responsible for turning the motor on and off that controls the apparatus that
// picks up the racket balls off the floor of the field
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void ballControl()
  {
    if (joy1Btn(6))
      {
        //pick up balls
        motor[ballMotor] = 100;
      }
    else if (joy1Btn(8))
      {
        //let go of balls
        motor[ballMotor] = -100;
      }
    else
      {
        motor[ballMotor] = 0;
      }
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Lifter Control
//
// This procedure is responsible for translating the joystick readings into motor power for the
// motors responsible for lifting and lowering the crate lifter apparatus
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void lifterControl()
  {
    int   lifterPower;
    float lifterMaxPower = 100.0;

    if (joy2Btn(1) && nudgeStatus == "waiting")
      {
        //wait for lift to finish previous command, move up if button is still down, wait for another command
        nudgeStatus = "moving";
        motor[leftLifterMotor]  = 50;
        motor[rightLifterMotor] = 50;
        wait1Msec(250);
        motor[leftLifterMotor]  = 0;
        motor[rightLifterMotor] = 0;
        wait1Msec(500);
        nudgeStatus = "waiting";
      }

     else if (joy2Btn(2) && nudgeStatus == "waiting")
      {
        //wait for lift to finish previous command, move down if button is still down, wait for another command
        nudgeStatus = "moving";
        motor[leftLifterMotor]  = -50;
        motor[rightLifterMotor] = -50;
        wait1Msec(150);
        motor[leftLifterMotor]  = 0;
        motor[rightLifterMotor] = 0;
        wait1Msec(500);
        nudgeStatus = "waiting";
      }
    else
      {
        //if neither button is down use joystick to move lift
        lifterPower = adjJoystickMotorPowerExp(joystick.joy2_y1, lifterMaxPower, 5);

        //Adjust power levels if lifter is descending
        if (lifterPower < 0)
          {
            lifterPower = min(0, lifterPower + 20);
          }

        motor[leftLifterMotor]  = lifterPower;
        motor[rightLifterMotor] = lifterPower;
      }
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Gripper Control
//
// This procedure is responsible for controlling the servos that move the gripper arms in and out
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void GripperControl()
  {
    int vGripperInterval = 2;
    int vMinLeftGripper  = 90;
    int vMaxRightGripper = 180;

    if (joy2Btn(5)) //move left side in
      {
        if(joy2Btn(3)) //move only bottom left
          {
            leftGripperPosition     = ServoValue[leftGripperServo];
            servo[leftGripperServo] = leftGripperPosition + vGripperInterval;
          }
        else if (joy2Btn(4)) //move only top left
          {
            TleftGripperPosition     = ServoValue[TleftGripperServo];
            servo[TleftGripperServo] = TleftGripperPosition + vGripperInterval;
          }
        else //move both top and bottom left
          {
            AllLeftGripperPosition = max(ServoValue[leftGripperServo],ServoValue[TleftGripperServo]);

            leftGripperPosition  = AllLeftGripperPosition;
            TleftGripperPosition = AllLeftGripperPosition;

            servo[leftGripperServo]  = AllLeftGripperPosition + vGripperInterval;
            servo[TleftGripperServo] = AllLeftGripperPosition + vGripperInterval;
          }
      }
    else if (joy2Btn(7)) //move left out
      {
        if (joy2Btn(3)) //move only bottom left
          {
            leftGripperPosition     = ServoValue[leftGripperServo];
            servo[leftGripperServo] = max(leftGripperPosition - vGripperInterval, vMinLeftGripper);
          }
        else if (joy2Btn(4))//move only top left
          {
            TleftGripperPosition     = ServoValue[TleftGripperServo];
            servo[TleftGripperServo] = max(TleftGripperPosition - vGripperInterval, vMinLeftGripper);
          }
        else //move top and bottom
          {
            AllLeftGripperPosition = min(ServoValue[leftGripperServo],ServoValue[TleftGripperServo]);

            leftGripperPosition  = AllLeftGripperPosition;
            TleftGripperPosition = AllLeftGripperPosition;

            servo[leftGripperServo]  = max(AllLeftGripperPosition - vGripperInterval, vMinLeftGripper);
            servo[TleftGripperServo] = max(AllLeftGripperPosition - vGripperInterval, vMinLeftGripper);
          }
      }
    else //keep arms in same place after button has been released
      {
        servo[leftGripperServo]  = leftGripperPosition;
        servo[TleftGripperServo] = TleftGripperPosition;
      }

    if (joy2Btn(8)) //move right out
      {
        if (joy2Btn(3)) //move only top right
          {
            rightGripperPosition     = ServoValue[rightGripperServo];
            servo[rightGripperServo] = min(rightGripperPosition + vGripperInterval, vMaxRightGripper);
          }
        else if (joy2Btn(4)) //move only bottom right
          {
            TrightGripperPosition     = ServoValue[TrightGripperServo];
            servo[TrightGripperServo] = min(TrightGripperPosition + vGripperInterval, vMaxRightGripper);
          }
        else //move top and bottom
          {
            AllRightGripperPosition = max(ServoValue[rightGripperServo],ServoValue[TrightGripperServo]);

            rightGripperPosition  = AllRightGripperPosition;
            TrightGripperPosition = AllRightGripperPosition;

            servo[rightGripperServo]  = min(AllRightGripperPosition + vGripperInterval, vMaxRightGripper);
            servo[TrightGripperServo] = min(AllRightGripperPosition + vGripperInterval, vMaxRightGripper);
          }
      }
    else if (joy2Btn(6)) //move right in
      {
        if (joy2Btn(3)) //move only top right
          {
            rightGripperPosition     = ServoValue[rightGripperServo];
            servo[rightGripperServo] = rightGripperPosition - vGripperInterval;
          }
        else if (joy2Btn(4)) //move only bottom right
          {
            TrightGripperPosition     = ServoValue[TrightGripperServo];
            servo[TrightGripperServo] = TrightGripperPosition - vGripperInterval;
          }
        else //move top and bottom
          {
            AllRightGripperPosition = min(ServoValue[rightGripperServo],ServoValue[TrightGripperServo]);

            rightGripperPosition  = AllRightGripperPosition;
            TrightGripperPosition = AllRightGripperPosition;

            servo[rightGripperServo]  = AllRightGripperPosition - vGripperInterval;
            servo[TrightGripperServo] = AllRightGripperPosition - vGripperInterval;
          }
      }
    else //keep arms at same position after button has been released
      {
        servo[rightGripperServo]  = rightGripperPosition;
        servo[TrightGripperServo] = TrightGripperPosition;
      }
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Sound Control
//
// This procedure is responsible for playing the A-Team sound bytes at the end of the match when a
// button is pressed
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void soundControl()
  {
    //play only if not already playing
    if (joy1Btn(2) && !bSoundActive)
      {
        servo[flagServo] = 100;
        PlaySoundFile("Love plan.rso");
        PlaySoundFile("The A-Team - Ending.rso");
      }
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the tele-op robot operation.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
//   1. Loop forever repeating the following actions:
//   2. Get the latest game controller / joystick settings that have been received from the PC.
//   3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
//      simple action:
//      *  Joystick values are usually directly translated into power levels for a motor or
//         position of a servo.
//      *  Buttons are usually used to start/stop a motor or cause a servo to move to a specific
//         position.
//   4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
task main()
  {
    initializeRobot();

    waitForStart();   // wait for start of tele-op phase

    while (true)
      {
        getJoystickSettings(joystick);
        movementControl();
        ballControl();
        lifterControl();
        GripperControl();
        soundControl();
      }
  }
