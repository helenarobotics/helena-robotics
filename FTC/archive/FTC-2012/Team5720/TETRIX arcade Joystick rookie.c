#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,                    sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     leftDrive,     tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     rotationArmMotor,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     conveyorMotor, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     liftArmMotor,  tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     rightDrive,    tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorNormal, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    clawServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    conveyorDumpServo,    tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    bowlingBallServo,     tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*--------------------------------------------------------------------------------------------------------*\
|*                                                                                                        *|
|*                                    - Tetrix Quiet  Tank Drive -                                        *|
|*                                          ROBOTC on Tetrix                                              *|
|*                                                                                                        *|
|*  This program allows you to drive a robot via remote control using the ROBOTC Debugger.                *|
\*--------------------------------------------------------------------------------------------------------*/

#include "JoystickDriver.c"

// This allows us to ignore low readings that keep our robot in perpetual motion.
const int JOY_THRESHOLD = 10;

// Motor constants and state
const int CHOOSE_DRIVEMODE = 0;
const int ARCADE_DRIVE = 1;
const int TANK_DRIVE = 2;
const int MOTOR_POWER_INCREMENT = 20;
bool reverseDirection;
int pcntPow;
int DRIVE_MODE;

// Conveyor
const int CONVEYOR_POWER = 100;
bool conveyorOn = false;
const int CONVEYOR_DUMP_UP_POS = 130;
const int CONVEYOR_DUMP_DOWN_POS = 0;
bool conveyorDumpUp;

// CLAWS
const int CLAWS_IN_POS = 0;
const int CLAWS_OUT_POS = 200;
bool clawsIn;

// Ball Capture arm
const int BALLCAPTURE_UP_POS = 210;
const int BALLCAPTURE_DOWN_POS = 70;
bool ballCaptureUp;

void initializeRobot()
{
    // Default to full power on the motors, but turn them off.
    pcntPow = 100;
    motor[leftDrive] = 0;
    motor[rightDrive] = 0;
    DRIVE_MODE = CHOOSE_DRIVEMODE;
    reverseDirection = false;

    // Move the bowling ball capture arm up
    servo[bowlingBallServo] = BALLCAPTURE_UP_POS;
    ballCaptureUp = true;

    // Default the claws to be in
    servo[clawServo] = CLAWS_IN_POS;
    clawsIn = true;

    // Conveyor Off and Arm Up
    motor[conveyorMotor] = 0;
    conveyorOn = false;
    servo[conveyorDumpServo] = CONVEYOR_DUMP_UP_POS;
    conveyorDumpUp = true;

    // Turn off the arm motors
    motor[liftArmMotor] = 0;
    motor[rotationArmMotor] = 0;
}

bool btnBBWP = false;
void moveBowlingBallServo()
{
    // Toggle the servo location when the button is released.
    bool btnBBIP = joy1Btn(4);
    if (!btnBBIP && btnBBWP)
        ballCaptureUp = !ballCaptureUp;
    btnBBWP = btnBBIP;

    if (ballCaptureUp) {
        servo[bowlingBallServo] = BALLCAPTURE_UP_POS;
    } else {
        servo[bowlingBallServo] = BALLCAPTURE_DOWN_POS;
    }
}

// Reverse direction, SpeedDecrease, and SpeedIncrease buttons
bool btnRDWP = false, btnSDWP = false, btnSIWP = false;
void moveRobot()
{
    int lPow = 0;
    int rPow = 0;
    if (DRIVE_MODE == CHOOSE_DRIVEMODE) {
        // Choose the drive mode
        if (joy1Btn(5)) {
            DRIVE_MODE = TANK_DRIVE;
        } else if (joy1Btn(6)) {
            DRIVE_MODE = ARCADE_DRIVE;
        }
    } else if (DRIVE_MODE == TANK_DRIVE) {
        // Make sure the joystick is read past the 'threshold' value
        if (abs(joystick.joy1_y1) > JOY_THRESHOLD)
            // Move proportionally
            lPow = joystick.joy1_y1 / 1.28;

        if (abs(joystick.joy1_y2) > JOY_THRESHOLD)
            // Move proportionally
            rPow = joystick.joy1_y2 / 1.28;
    } else if (DRIVE_MODE == ARCADE_DRIVE) {
        int nSpeedPower = 0;
        int nTurnPower = 0;
        if (abs(joystick.joy1_y1) > JOY_THRESHOLD)
            nSpeedPower = joystick.joy1_y1 / 1.28;
        if (abs(joystick.joy1_x2) > JOY_THRESHOLD)
            nTurnPower = joystick.joy1_x2 / 1.28;

        // Power and speed
        rPow = nSpeedPower - nTurnPower;
        lPow = nSpeedPower + nTurnPower;

        // If we're turning, halve the power
        if (abs(nTurnPower) > 0 && abs(nSpeedPower) > 25) {
            rPow /= 2;
            lPow /= 2;
        }
    }

    // Scale the motor power down
    lPow = lPow * pcntPow / 100;
    rPow = rPow * pcntPow / 100;

    // Reverse the front and rear of robot
    if (reverseDirection) {
        int tempL = lPow;
        lPow = -rPow;
        rPow = -tempL;
    }
    motor[leftDrive] = lPow;
    motor[rightDrive] = rPow;

    if (DRIVE_MODE != CHOOSE_DRIVEMODE) {
        // Buttons 5 and 6 decrease/increase the power in incremental chunks
        bool btnSDIP = joy1Btn(5);
        if (btnSDIP && !btnSDWP) {
            if (pcntPow > MOTOR_POWER_INCREMENT)
                pcntPow -= MOTOR_POWER_INCREMENT;
        }
        btnSDWP = btnSDIP;

        bool btnSIIP = joy1Btn(6);
        if (btnSIIP && !btnSIWP) {
            if (pcntPow <= (100 - MOTOR_POWER_INCREMENT))
                pcntPow += MOTOR_POWER_INCREMENT;
        }
        btnSIWP = btnSIIP;

        // Reverse the front and rear directions
        bool btnRDIP = joy1Btn(1);
        if (btnRDIP && !btnRDWP)
            reverseDirection = !reverseDirection;
        btnRDWP = btnRDIP;
    }
}

void moveLiftArm()
{
    if (abs(joystick.joy2_y1) > JOY_THRESHOLD)
    {
        motor[liftArmMotor] = joystick.joy2_y1;
    }
    else
    {
        motor[liftArmMotor] = 0;
    }
}

void moveRotationArm()
{
    if (abs(joystick.joy2_y2) > JOY_THRESHOLD)
    {
        motor[rotationArmMotor] = joystick.joy2_y2;
    }
    else
    {
        motor[rotationArmMotor] = 0;
    }
}

bool btnBCWP = false;
void toggleBallConveyor()
{
    // Toggle the conveyor on/off
    bool btnBCIP = joy1Btn(7);
    if (!btnBCIP && btnBCWP)
        conveyorOn = !conveyorOn;
    btnBCWP = btnBCIP;

    // Enable the ball conveyor
    if (conveyorOn)
    {
        motor[conveyorMotor] = CONVEYOR_POWER;
    }
    else
    {
        motor[conveyorMotor] = 0;
    }
}

bool btnClawWP = false;
void toggleClaws()
{
    // Toggle the servo location when the button is released.
    bool btnClawIP = joy2Btn(5);
    if (!btnClawIP && btnClawWP)
        clawsIn = !clawsIn;
    btnClawWP = btnClawIP;

    // Claws
    if (clawsIn)
    {
        servo[clawServo] = CLAWS_IN_POS;
    }
    else
    {
        servo[clawServo] = CLAWS_OUT_POS;
    }
}

bool btnCDWP = false;
void toggleConveyorDump()
{
    // Toggle the servo location when the button is released.
    bool btnCDIP = joy2Btn(6);
    if (!btnCDIP && btnCDWP)
        conveyorDumpUp = !conveyorDumpUp;
    btnCDWP = btnCDIP;

    if (conveyorDumpUp)
    {
        servo[conveyorDumpServo] = CONVEYOR_DUMP_UP_POS;
    }
    else
    {
        servo[conveyorDumpServo] = CONVEYOR_DUMP_DOWN_POS;
    }
}

// Main routine
task main()
{
    initializeRobot();

    // wait for start of tele-op phase
    waitForStart();

    // Infinite loop:
    while (true)
    {
        getJoystickSettings(joystick);

        // Drive the robot
        moveRobot();

        // Rear bowling ball capture frame
        moveBowlingBallServo();

        // Lift Arm
        moveLiftArm();

        // Rotation Arm
        moveRotationArm();

        // Ball conveyor
        toggleBallConveyor();

        // Claws
        toggleClaws();

        //Conveyor dump
        toggleConveyorDump();
    }
}
