#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S3,     irSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     DriveLeft,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Ramp,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     LeftLifter1,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     LeftLifter2,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     DriveRight,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     motorA,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     RightLifter1,  tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C2_2,     RightLifter2,  tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C3_1,    IR,                   tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    pivotLeft,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    pivotRight,           tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth or wifi messages from the FCS and Joysticks
#include "drivers/3rdPartyDrivers/hitechnic-gyro.h"  //Include file for the gyro sensor utilities

// Define an enumeration list for the driving commands
typedef enum
{
	FORWARD,
	BACKWARD,
	LEFT,
	RIGHT,
} driveState;

// Define an enumeration list for the lift commands
typedef enum
{
	UP,
	DOWN,
} liftState;

// Define an enumeration list for debug mode
typedef enum
{
	ON,
	OFF
} debugState;

// GLOBAL CONSTANTS
const int    gcThreshHold    = 5;  //Defines how many encoder ticks a motor must travel during each interval or else
                                   //the program thinks the robot has collided with something
const long   gcSyncInterval  = 250; //Defines the time interval between each check for collision and PID correction
const long   gcSyncTickError = 50;  //Defines how far the motors can be "off" before needing correction 50 ticks = ~12 degrees
const string gcBeaconRing    = "BeaconRing"; //Defines an autonomous option to use the beacon to place a ring
const string gcPlaceRing     = "PlaceRing";  //Defines an autonomous option to place a ring without using the beacon
const string gcDefense       = "Defense";    //Defines an autonomous option to play defense
const string gcCDefense      = "CDefense";   //Defines an autonomous option to counter a defensive robot
const string gcLeft          = "Left";
const string gcRight         = "Right";

// GLOBAL VARIABLES
int    gReady   = 0; // Counter used to determine if we are done selecting the autonomous routine
string gRun[]   = {gcBeaconRing, gcPlaceRing, gcDefense, gcCDefense};
int    gRunIdx  = 0;
string gSide[]  = {gcLeft, gcRight};
int    gSideIdx = 0;
int    gPos     = 1;
int    gPath    = 1;
int    gHeight  = 1;

//Set the debug mode to off by default
debugState debugMode = OFF;


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    ButtonTask
//
// This task monitors the use of the NXT buttons when selecting the autonomous routine and setting up
// any global variables
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
task ButtonTask()
{
	nSchedulePriority = kHighPriority;

	switch(nNxtButtonPressed)
	{
		case kLeftButton:
			if (gReady == 0)
			{
				gRunIdx--;

				if (gRunIdx < 0)
				{
					gRunIdx = 3;
				}

				nxtDisplayTextLine(2, gRun[gRunIdx]);
			}
			else if (gReady == 1)
			{
				gSideIdx--;

				if (gSideIdx < 0)
				{
					gSideIdx = 1;
				}

				nxtDisplayTextLine(3, "Side: %s", gSide[gSideIdx]);
			}
			else if (gReady == 2)
			{
				gPos--;

				if (gPos<1)
				{
					gPos=3;
				}

				nxtDisplayTextLine(4, "Position: %i", gPos);
			}
			else if (gReady == 3)
			{
				gPath--;

				if (gPath<1)
				{
				gPath=3;
			}

			nxtDisplayTextLine(5, "Column: %i", gPath);
			}
			else if (gReady == 4)
			{
				gHeight--;

				if (gHeight<1)
				{
					gHeight=3;
				}

				nxtDisplayTextLine(6, "Row: %i", gHeight);
			}

			break;
		case kRightButton:
			if (gReady == 0)
			{
				gRunIdx++;

				if (gRunIdx > 3)
				{
					gRunIdx = 0;
				}

				nxtDisplayTextLine(2, gRun[gRunIdx]);
			}
			else if (gReady == 1)
			{
				gSideIdx++;

				if (gSideIdx > 1)
				{
					gSideIdx = 0;
				}

				nxtDisplayTextLine(3, "Side: %s", gSide[gSideIdx]);
			}
			else if (gReady == 2)
			{
				gPos++;

				if (gPos>3)
				{
					gPos=1;
				}

				nxtDisplayTextLine(4, "Position: %i", gPos);
			}
			else if (gReady == 3)
			{
				gPath++;

				if (gPath>3)
				{
					gPath=1;
				}

				nxtDisplayTextLine(5, "Column: %i", gPath);
			}
			else if (gReady == 4)
			{
				gHeight++;

				if (gHeight>3)
				{
					gHeight=1;
				}

				nxtDisplayTextLine(6, "Row: %i", gHeight);
			}

			break;
		case kEnterButton:
			gReady++;

			if (gReady == 1)
			{
				nxtDisplayTextLine(3, "Side: %s", gSide[gSideIdx]);
			}
			else if (gReady == 2)
			{
				nxtDisplayTextLine(4, "Position: %i", gPos);
			}
			else if (gReady == 3)
			{
				nxtDisplayTextLine(5, "Column: %i", gPath);
			}
			else if (gReady == 4)
			{
				nxtDisplayTextLine(6, "Row: %i", gHeight);
			}

			break;
		case kExitButton:
			gReady--;

			if (gReady < 0)
			{
				gReady = 0;
			}

			if (gReady == 0)
			{
				nxtDisplayClearTextLine(3);
			}
			else if (gReady == 1)
			{
				nxtDisplayClearTextLine(4);
			}
			else if (gReady == 2)
			{
				nxtDisplayClearTextLine(5);
			}
			else if (gReady == 3)
			{
				nxtDisplayClearTextLine(6);
			}

			break;
	}

	return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void initializeRobot()
{
	//Initialize the position of the servos that control our ring arm
	servo[pivotLeft] = 0;
	servo[pivotRight] = 255;

	//By default the NXT display will show diagnostics. This line disables that so we can display what
	//we want to
	disableDiagnosticsDisplay();
	eraseDisplay();
	nxtDisplayCenteredTextLine(1, "Autonomous");
	nxtDisplayTextLine(2, gRun);  //Sets line 2 of the display to show what routine is currently selected

	nNxtButtonTask = ButtonTask;  //Starts up the button task defined above for selecting the auto routine
	nNxtExitClicks = 2; //Normally the gray NXT button exits the program, but since we use the exit button
	//to "back up", we reset the exit clicks to 2 so that a double click will exit the
	//program

	while (gReady < 5)
	{
		//Do nothing. This loop puts us in a wait mode while a team member selects the program,
		//alliance color, and position of the robot, etc using the button task above
	}

	nxtDisplayCenteredTextLine(7, "READY"); //Selection is done so display ready on the screen

	//Calibrate the gyro sensor while the robot is still
	HTGYROstartCal(gyro);
	wait1Msec(1000);

	//In order to speed up the sensing of the IR beacon, we initialize the servo for the IR seeker based
	//on which side the robot was placed on
	if (strcmp(gSide, "left")== 0)
	{
		servo[IR] = 50;
	}
	else
	{
		servo[IR] = 175;
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    move
//
// This is a generic movement routine that handles turning the motors on and off as well as
// watching encoder values to detect when movement is impaired.
//
// note: the distance value should be in inches
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void move(int iSpeed, int iDistance, driveState iCmd)
{
	//Set up variables
	//For the encoder tic we multiply the incoming distance by the calculated number of tics when
	//traveling one inch. To get the calculated value you must figure out the circumference of the
	//wheel, tread, etc. There are 1440 tics in a single revolution of the motor
	int  vEncoderTic   = 115 * iDistance;
	int  vPrevLeftPos  = 0;
	int  vPrevRightPos = 0;
	int  vCurrLeftPos  = 0;
	int  vCurrRightPos = 0;
	int  vLeftPower    = iSpeed;
	int  vRightPower   = iSpeed;
	int  vRightOffset  = 1;
	int  vLeftOffset   = 1;
	int  vSpeed        = iSpeed;

	unsigned long vNxtSyncTime  = nPgmTime + gcSyncInterval;

	//Set our motor offsets based on the supplied command
	switch (iCmd)
	{
	case FORWARD:
		//To move forward both motor powers should be positive
		vRightOffset = 1;
		vLeftOffset  = 1;
		break;
	case BACKWARD:
		//To move backward both motor powers should be negative
		vRightOffset = -1;
		vLeftOffset  = -1;
		break;
	case LEFT:
		//To spin left, the left motor must run backward and the right motor forward
		vRightOffset = 1;
		vLeftOffset  = -1;
		break;
	case RIGHT:
		//To spin right, the right motor must run backward and the left motor forward
		vRightOffset = -1;
		vLeftOffset  = 1;
		break;
	}

	//Reset our encoders prior to movement
	nMotorEncoder[DriveLeft]  = 0;
	nMotorEncoder[DriveRight] = 0;

	//Start up the motors
	motor[DriveLeft]  = vLeftPower * vLeftOffset;
	motor[DriveRight] = vRightPower * vRightOffset;

	//Loop until both motors have traveled the required distance
	while(abs(nMotorEncoder[DriveLeft]) < vEncoderTic || abs(nMotorEncoder[DriveRight]) < vEncoderTic)
	{
		//Determine the current value of the encoders
		vCurrLeftPos  = abs(nMotorEncoder[DriveLeft]);
		vCurrRightPos = abs(nMotorEncoder[DriveRight]);

		//We only perform error correction at specific intervals
		if (nPgmTime >= vNxtSyncTime)
		{
			//See if we are far enough 'out of sync' to warrant speed corrections
			//To do this, we average the encoder values and then compare each individual motor to that average
			int vAvg = (vCurrLeftPos + vCurrRightPos) / 2;

			if (abs(vCurrLeftPos - vAvg) > gcSyncTickError || abs(vCurrRightPos - vAvg) > gcSyncTickError)
			{
				//We are out of sync. Determine which side is falling behind the other and adjust the speed
				//We default to slowing down the motors. The only time we speed up a motor is if it was
				//previously slowed
				if (vCurrLeftPos < vCurrRightPos)
				{
					if (vLeftPower < vSpeed)
					{
						vLeftPower       = vLeftPower + 1;
						motor[DriveLeft] = vLeftPower * vLeftOffset;
					}
					else
					{
						vRightPower       = vRightPower - 1;
						motor[DriveRight] = vRightPower * vRightOffset;
					}
				}
				else
				{
					if (vRightPower < vSpeed)
					{
						vRightPower       = vRightPower + 1;
						motor[DriveRight] = vRightPower * vRightOffset;
					}
					else
					{
						vLeftPower       = vLeftPower - 1;
						motor[DriveLeft] = vLeftPower * vLeftOffset;
					}
				}
			}

			//Now we check to ensure we have not run into an object preventing us from moving.
			if ((vCurrLeftPos <= (vPrevLeftPos + gcThreshHold)) || (vCurrRightPos <= (vPrevRightPos + gcThreshHold)))
			{
				//At least one motor is stuck. Turn off motors and wait for a period of time to avoid motor burn out.
				motor[DriveLeft]  = 0;
				motor[DriveRight] = 0;

				wait1Msec(1000);

				vSpeed = 50;
				vLeftPower  = vSpeed;
				vRightPower = vSpeed;

				motor[DriveLeft]  = vLeftPower * vLeftOffset;
				motor[DriveRight] = vRightPower * vRightOffset;
			}
			else if (vSpeed < iSpeed)
			{
				//We have cleared whatever was obstructing the robot so go ahead and speed back up
				vSpeed = iSpeed;
				vLeftPower  = vSpeed;
				vRightPower = vSpeed;

				motor[DriveLeft]  = vLeftPower * vLeftOffset;
				motor[DriveRight] = vRightPower * vRightOffset;
			}

			//Use the interval to calculate the next sync time
			vNxtSyncTime = nPgmTime + gcSyncInterval;

			//Store the current positions in the previous position values for the next time through the loop
			vPrevLeftPos  = vCurrLeftPos;
			vPrevRightPos = vCurrRightPos;
		}
	}

	//We finished our movement so turn off the motors
	motor[DriveLeft]  = 0;
	motor[DriveRight] = 0;

	//The following line is used to pause the robot in between movements
	wait1Msec(100);
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    move lift
//
// This is a generic movement routine that handles turning the motors on and off as well as
// watching encoder values to detect when movement is impaired.
//
// note: distance is measured in encoder tics
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void moveLift(int iSpeed, int iDistance, liftState iCmd)
{
	int  vPrevPos    = 0;
	int  vCurrPos    = 0;
	int  vOffset;
	long vEncoderTic = abs(iDistance);

	unsigned long vNxtSyncTime = nPgmTime + gcSyncInterval;

	//Set our motor offsets based on the supplied command
	switch (iCmd)
	{
	case UP:
		//To move forward both motor powers should be positive
		vOffset = 1;
		break;
	case DOWN:
		//To move backward both motor powers should be negative
		vOffset = -1;
		break;
	}

	//Reset our encoders prior to movement
	nMotorEncoder[RightLifter1]  = 0;

	//Start up the motors
	motor[LeftLifter1]  = iSpeed * vOffset;
	motor[LeftLifter2]  = iSpeed * vOffset;
	motor[RightLifter1] = iSpeed * vOffset;
	motor[RightLifter2] = iSpeed * vOffset;

	//Loop until motors have traveled the required distance
	while(abs(nMotorEncoder[RightLifter1]) < vEncoderTic)
	{
		//Determine the current value of the encoders
		vCurrPos = abs(nMotorEncoder[RightLifter1]);

		//We only perform error correction at specific intervals
		if (nPgmTime >= vNxtSyncTime)
		{
			//Now we check to ensure we have not run into an object preventing us from moving.
			if (vCurrPos <= (vPrevPos + gcThreshHold))
			{
				//At least one motor is stuck. Turn off motors and wait for a period of time to avoid motor burn out.
				motor[LeftLifter1]  = 0;
				motor[LeftLifter2] = 0;
				motor[RightLifter1]  = 0;
				motor[RightLifter2] = 0;

				wait1Msec(1000);

				motor[LeftLifter1]  = iSpeed * vOffset;
				motor[LeftLifter2]  = iSpeed * vOffset;
				motor[RightLifter1] = iSpeed * vOffset;
				motor[RightLifter2] = iSpeed * vOffset;
			}

			vNxtSyncTime = nPgmTime + gcSyncInterval;

			vPrevPos  = vCurrPos;
		}
	}

	motor[LeftLifter1]  = 0;
	motor[LeftLifter2] = 0;
	motor[RightLifter1]  = 0;
	motor[RightLifter2] = 0;

	//The following line is used to pause the robot in between movements
	wait1Msec(100);
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    GyroTurn
//
// This is a generic movement routine that turns the robot a specific number of degrees using a gyro
// sensor to measure angular velocity
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void GyroTurn(int iSpeed, int iDegrees, driveState iCmd)
{
	float vcurrposition = 0;
	int   vprevtime     = nPgmTime;
	int   vcurrtime;
	float vcurrRate;
	int   voffset;
	float deltaSecs;
	float degChange;

	if (iCmd == LEFT)
	{
		motor[DriveLeft]  = -1 * iSpeed;
		motor[DriveRight] = iSpeed;
		voffset = -1;
	}
	else
	{
		motor[DriveLeft]  = iSpeed;
		motor[DriveRight] = -1 * iSpeed;
		voffset = 1;
	}

	while (vcurrposition < iDegrees)
	{
		// This tells us the current rate of rotation in degrees per
		// second.
		vcurrRate = HTGYROreadRot(gyro) * voffset;

		// How much time has elapsed since we last checked, which we use
		// to determine how far we've turned
		vcurrtime = nPgmTime;

		deltaSecs = (vcurrtime - vprevtime) / 1000.0;
		if (deltaSecs < 0)
		{
			deltaSecs = ((float)((vcurrtime + 1024) - (vprevtime + 1024))) / 1000.0;
		}

		// Calculate how many degrees the heading changed.
		degChange = vcurrRate * deltaSecs;
		vcurrposition = vcurrposition + degChange;
		vprevtime = vcurrtime;
	}

	motor[DriveLeft]  = 0;
	motor[DriveRight] = 0;

	//The following line is used to pause the robot in between movements
	wait1Msec(100);
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    findBeacon
//
// This routine uses the IR seeker sensor to orient the robot based on the IR beacon
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
int findBeacon(int iPos, string iSide)
{
	int SensorVal1;
	int BeaconPos;

	//First we must turn the robot until the beacon is in front of us
	if (strcmp(iSide, "left")== 0)
	{
		nxtDisplayCenteredTextLine(5, "Left");

		while (SensorValue[irSeeker] < 7 && ServoValue[IR] < 255)
		{
			servo[IR] = ServoValue[IR] + 1;
		}
	}
	else
	{
		nxtDisplayCenteredTextLine(5, "Right");

		while (SensorValue[irSeeker] > 3 && ServoValue[IR] > 0)
		{
			servo[IR] = ServoValue[IR] - 1;
		}
	}

	SensorVal1 = ServoValue[IR];

	BeaconPos = ServoValue[IR];

	if (debugMode == ON)
	{
		eraseDisplay();
		nxtDisplayCenteredTextLine(1, "Beacon Found");
		nxtDisplayTextLine(3, "%i",BeaconPos);
		wait10Msec (10000);
	}

	if (iPos == 1)
	{
		if (strcmp(iSide, "left")== 0)
		{
			if (BeaconPos < 78)
			{
				return 1;
			}
			else if (BeaconPos < 97)
			{
				return 2;
			}
			else
			{
				return 3;
			}
		}
		else
		{
			if (BeaconPos < 94)
			{
				return 3;
			}
			else if (BeaconPos < 114)
			{
				return 2;
			}
			else
			{
				return 1;
			}
		}
	}
	else if (iPos == 2)
	{
		if (strcmp(iSide, "left")== 0)
		{
			if (BeaconPos < 91)
			{
				return 1;
			}
			else if (BeaconPos < 114)
			{
				return 2;
			}
			else
			{
				return 3;
			}
		}
		else
		{
			if (BeaconPos < 78)
			{
				return 3;
			}
			else if (BeaconPos < 103)
			{
				return 2;
			}
			else
			{
				return 1;
			}
		}
	}
	else
	{
		return 1;
	}
}


//////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Path 1
//
// Move forward, turn to closest side of rack, move forward, turn towards rack
//
/////////////////////////////////////////////////////////////////////////////////////////////////
void path1 (string iSide, int iDist1, int iDist2)
{
	move (50,12,FORWARD);

	if (strcmp(iSide, "left")== 0)
	{
		GyroTurn (50, 90, LEFT);
	}
	else
	{
		GyroTurn (50, 90, RIGHT);
	}

	move (50, iDist1, FORWARD);

	if (strcmp(iSide, "left")== 0)
	{
		GyroTurn (50, 45, RIGHT);
	}
	else
	{
		GyroTurn (50, 45, LEFT);
	}

	move (40, iDist2, FORWARD);
}


//////////////////////////////////////////////////////////////////////////////////////////////////
//                                       Path 2
//
// Drive straight, turn toward rack
//
/////////////////////////////////////////////////////////////////////////////////////////////////
void path2 (string iSide, int iDist1, int iDist2)
{
	move (50, iDist1, FORWARD);

	if (strcmp(iSide, "left")== 0)
	{
		GyroTurn (50, 45, LEFT);
	}
	else
	{
		GyroTurn (50, 45, RIGHT);
	}

	move (50, iDist2, FORWARD);
}


//////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Path 3
//
// Move forward, turn to farthest side of rack, move forward, turn to rack
//
/////////////////////////////////////////////////////////////////////////////////////////////////
void path3 (string iSide, int iDist)
{
	move (50, 15, FORWARD);

	if (strcmp(iSide, "left")== 0)
	{
		GyroTurn (50, 45, RIGHT);
	}
	else
	{
		GyroTurn (50, 45, LEFT);
	}

	move (50, iDist, FORWARD);

	if (strcmp(iSide, "left")== 0)
	{
		GyroTurn (50, 90, LEFT);
	}
	else
	{
		GyroTurn (50, 90, RIGHT);
	}

	move (50, 22, FORWARD);
}


//////////////////////////////////////////////////////////////////////////////////////////////////
//                                       place ring
//
// Place autonomous ring while sensing the IR beacon
//
/////////////////////////////////////////////////////////////////////////////////////////////////
void placering (string iSide, int iPos, int iColumn, int iHeight)
{
	if (iColumn == 2)
	{
		moveLift (0, 0, UP);
	}
	else
	{
		if (iHeight == 1)
		{
			moveLift(40, 571, UP);
		}
		else if (iHeight == 2)
		{
			moveLift(40, 3095, UP);
		}
		else if (iHeight == 3)
		{
			moveLift(40, 5233, UP);
		}
	}

	if (iPos == 1)
	{
		if (iColumn == 1)
		{
			path1 (iSide,33, 15);
		}
		else if (iColumn == 2)
		{
			move(50, 16, FORWARD);

			if (strcmp(iSide, "left")== 0)
			{
				GyroTurn (50, 45, LEFT);
			}
			else
			{
				GyroTurn (50, 45, RIGHT);
			}

			move(50, 21, FORWARD);

			if (strcmp(iSide, "left")== 0)
			{
				GyroTurn (50, 45, LEFT);
			}
			else
			{
				GyroTurn (50, 45, RIGHT);
			}

			move(50, 13, FORWARD);

			if (strcmp(iSide, "left")== 0)
			{
				GyroTurn (50, 30, RIGHT);
			}
			else
			{
				GyroTurn (50, 30, LEFT);
			}

			move(50, 1, BACKWARD);

			moveLift(40, 500, UP);

			move(50, 3, FORWARD);
		}
		else if (iColumn == 3)
		{
			path2 (iSide, 20, 31);
		}
	}
	else if (iPos == 2)
	{
		if (iColumn == 1)
		{
			path1 (iSide, 15, 12);
		}
		else if (iColumn == 2)
		{
			move(50, 33, FORWARD);

			if (strcmp(iSide, "left")== 0)
			{
				GyroTurn (50, 90, LEFT);
			}
			else
			{
				GyroTurn (50, 90, RIGHT);
			}

			move(50, 19, FORWARD);

			if (strcmp(iSide, "left")== 0)
			{
				GyroTurn (50, 30, RIGHT);
			}
			else
			{
				GyroTurn (50, 30, LEFT);
			}

			move(50, 2, BACKWARD);

			moveLift(40, 500, UP);

			move(50, 3, FORWARD);
		}
		else if (iColumn == 3)
		{
			path2 (iSide, 35, 13);
		}
	}
	else if (iPos == 3)
	{
		if (iColumn == 1)
		{
			path1 (iSide, 12, 14);
		}
		else if (iColumn == 2)
		{
			move(50, 12, FORWARD);

			if (strcmp(iSide, "left")== 0)
			{
				GyroTurn (50, 90, LEFT);
			}
			else
			{
				GyroTurn (50, 90, RIGHT);
			}

			move(50, 13, FORWARD);

			if (strcmp(iSide, "left")== 0)
			{
				GyroTurn (50, 90, RIGHT);
			}
			else
			{
				GyroTurn (50, 90, LEFT);
			}

			move(50, 18, FORWARD);

			if (strcmp(iSide, "left")== 0)
			{
				GyroTurn (50, 35, LEFT);
			}
			else
			{
				GyroTurn (50, 35, RIGHT);
			}

			move(50, 1, BACKWARD);

			moveLift(40, 500, UP);

			move(50, 4, FORWARD);
		}
		else if (iColumn == 3)
		{
			path3 (iSide, 15);
		}
	}

	servo[pivotLeft]  = 0;
	servo[pivotRight] = 255;

	if (iHeight == 1)
	{
		moveLift(40, 571, DOWN);
	}
	else if (iHeight == 2)
	{
		moveLift(40, 3095, DOWN);
	}
	else if (iHeight == 3)
	{
		moveLift(40, 5233,DOWN);
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////
///                                       Defense
///
//////////////////////////////////////////////////////////////////////////////////////////////////
void defense (string iSide, )
{
	int SensorVal1;
	int BeaconPos;

	if (strcmp(iSide, "left") == 0)
	{
		servo [IR] = 20;
	}
	else
	{
		servo [IR] = 235;
	}

	move (100, 34, FORWARD);

	if (strcmp(iSide, "left") == 0)
	{
		GyroTurn (100, 30, RIGHT);
	}
	else
	{
		GyroTurn (100, 30, LEFT);
	}

	move (100, 14, FORWARD);

	//First we must turn the servo until the beacon is in front of the seeker
	if (strcmp(iSide, "left")== 0)
	{
		while (SensorValue[irSeeker] < 7 && ServoValue[IR] < 255)
		{
			servo[IR] = ServoValue[IR] + 1;
		}
	}
	else
	{
		while (SensorValue[irSeeker] > 3 && ServoValue[IR] > 0)
		{
			servo[IR] = ServoValue[IR] - 1;
		}
	}

	SensorVal1 = ServoValue[IR];

	BeaconPos = ServoValue[IR];

	if (debugMode == ON)
	{
		eraseDisplay();
		nxtDisplayCenteredTextLine(1, "Beacon Found");
		nxtDisplayTextLine(3, "%i",BeaconPos);
		wait10Msec (10000);
	}

	if (BeaconPos < 175)
	{
		move(50, 0, FORWARD);
	}
	else if (BeaconPos > 176)
	{
		move(50, 14, FORWARD);
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                       Counter Defense
// The following is the main code for the autonomous counter defensive operation.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void cdefense ()
{
	move (100, 13, FORWARD);
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
task main()
{
	int vPath = 1;
	debugMode = OFF; //Change this value to ON if you want to turn on debugging

	initializeRobot();

	waitForStart(); // Wait for the beginning of autonomous phase.

	//////////////////////////////////////////
	// Run the selected autonomous routine
	//////////////////////////////////////////
	if (strcmp(gRun[gRunIdx], gcPlaceRing) == 0)
	{
		servo[pivotLeft] = 90;
		servo[pivotRight] = 165;

		placering(gSide[gSideIdx], gPos, gPath, gHeight);
	}
	else if (strcmp(gRun[gRunIdx], gcDefense) == 0)
	{
		defense (gSide[gSideIdx]);
	}
	else if (strcmp(gRun[gRunIdx], gcCDefense) == 0)
	{
		cdefense ();
	}
	else
	{
		servo[pivotLeft] = 90;
		servo[pivotRight] = 165;

		vPath = findBeacon(gPos, gSide[gSideIdx]);
		placering(gSide[gSideIdx], gPos, vPath, gHeight);
		//wait10Msec(1000);
	}
}
