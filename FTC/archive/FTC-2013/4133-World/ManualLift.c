#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     irSeeker,       sensorI2CMuxController)
#pragma config(Sensor, S3,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     DriveRight,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     DriveLeft,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     leftlifter1,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     leftlifter2,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     rightlifter1,  tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     rightlifter2,  tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S2_C3_1,    IR,                   tServoStandard)
#pragma config(Servo,  srvo_S2_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

int vready = 0;

task ButtonTask()
  {
    nSchedulePriority = kHighPriority;

		switch (nNxtButtonPressed)
		{
			case kLeftButton:
	    	motor[leftlifter1] = 70;
	    	motor[leftlifter2] = 70;	    	motor[rightlifter1] = 70;	    	motor[rightlifter2] = 70;	    	break;
	    case kRightButton:
	    	motor[leftlifter1] = -70;
	    	motor[leftlifter2] = -70;	    	motor[rightlifter1] = -70;	    	motor[rightlifter2] = -70;	    	break;
	    case kEnterButton:
	    	motor[leftlifter1] = 0;
	    	motor[leftlifter2] = 0;	    	motor[rightlifter1] = 0;	    	motor[rightlifter2] = 0;	    	break;
    }

    return;
  }

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
task main()
  {
  	disableDiagnosticsDisplay();
  	servo[IR] = 20;
  	wait10Msec(50);
    // Place code here to initialize servos to starting positions.
    // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
    eraseDisplay();
    nxtDisplayCenteredTextLine(1, "ManualLift");
    nxtDisplayTextLine(3, "press left for up");
    nxtDisplayTextLine(3, "press right for down");
		vready = 0;
    nNxtButtonTask = ButtonTask;
    nNxtExitClicks = 2;

    while (vready < 1)
      {
        //Do nothing. This loop puts us in a wait mode while a team member selects the program,
        //alliance color, and position of the robot
      }

    nxtDisplayCenteredTextLine(7, "READY");
  }
