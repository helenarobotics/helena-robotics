#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     irSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S1_C1_1,     DriveLeft,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Ramp,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     LeftLifter1,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     LeftLifter2,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     DriveRight,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     RightLifter1,  tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C2_2,     RightLifter2,  tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C3_1,    IR,                   tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    pivotLeft,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    pivotRight,           tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

string nudgeStatus;


const int vDispenser = 0;
const int vRack1 = 571;
const int vRack2 = 3095;
const int vRack3 = 5233;

int vRightPos;
int vLeftPos;
int vliftTarget;
int vPivotLeftBase;
int vPivotRightBase;

typedef enum
{
	WAITING,
	RAISING,
	LOWERING,
	JOYSTICK,
} liftStateEnum;

liftStateEnum liftState;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void initializeRobot()
  {
  	disableDiagnosticsDisplay();
    //initialize display to show teleop is ready
    eraseDisplay();
    nxtDisplayCenteredTextLine(1, "TeleOp");
    nxtDisplayCenteredTextLine(7, "READY");

    //set grippers to default position
    //LeftPivotPosition  = ServoValue[pivotleft];
    //RightPivotPosition = ServoValue[pivotright];
    vLeftPos = 0;
    vRightPos = 255;
    servo[pivotLeft] = 10;
    servo[pivotRight] = 245;

    wait10Msec(50);

    vPivotLeftBase = ServoValue[pivotLeft];
    vPivotRightBase = 255 - ServoValue[pivotRight];

    //initialize lifter nudge to be ready for command
    //nudgeStatus = "waiting";

   servo[IR] = 50;

   nMotorEncoder[RightLifter1] = 0;
   liftState = WAITING;
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                               Power
//
// Provides an exponential function for floating point numbers
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
float Power(float num, int exp)
  {
    // require positive integer for the exponent
    if (exp <= 0)
      {
        return 0;
      }

    float result = num;

    for (int i = 1; i < exp; i++)
      {
        result *= num;
      }

    return result;
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                               adjJoystickMotorPowerExp
//
// As the range of values for the joysticks are -128 to 127 and the range of power settings for the
// motors are -100 to 100. We must adjust the joystick values to be within the motor values using
// an exponential curve. This will allow the best control over our lifter.
//
// Also, since the joysticks do not always center exactly at position 0 when released, we use a
// thresh hold value to provide a small range of values that all equate to no movement
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
int adjJoystickMotorPowerExp(int i_joystickReading, float i_rangeMax, int i_threshHold)
  {
    const float vSensitivity = 0.7;
    const int   vExp         = 3;

    int vMotorPower = i_joystickReading;

    //Compare to the thresh hold to account for variations in calibration
    if (abs(vMotorPower) < i_threshHold)
      {
        vMotorPower = 0;
      }
    else
      {
        //The value is outside the thresh hold. We now need to adjust to the
        //desired range. To do this first we convert the value to a floating
        //point number between -1 and 1
        float vFloatPower = vMotorPower / 127.0;

        //Next we apply our exponential formula
        float result = vSensitivity * Power(vFloatPower, vExp) +
                       (1 - vSensitivity) * vFloatPower;

        //Finally we adjust for our range
        vMotorPower = (int)(i_rangeMax * result);
      }

    return vMotorPower;
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                               adjJoystickMotorPower
//
// As the range of values for the joysticks are -128 to 127 and the range of power settings for the
// motors are -100 to 100. We must adjust the joystick values to be within the motor values. This
// will allow the best driving experience for the robot.
//
// Also, since the joysticks do not always center exactly at position 0 when released, we use a
// thresh hold value to provide a small range of values that all equate to no movement
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
int adjJoystickMotorPower(int i_joystickReading, int i_rangeMax, int i_threshHold)
  {
    int vMotorPower = i_joystickReading;

    //Compare to the thresh hold to account for variations in calibration
    if (abs(vMotorPower) < i_threshHold)
      {
        vMotorPower = 0;
      }

    else
      {
        //The value is outside the thresh hold. We now need to adjust to the
        //desired range. To do this first we need to subtract our thresh hold value
      if (vMotorPower < 0)
      {
        vMotorPower = vMotorPower + i_threshHold;

        //Next we adjust for our range
        vMotorPower = floor((vMotorPower * i_rangeMax) / (127 - i_threshHold));
      }
      else
      {
      	vMotorPower = vMotorPower - i_threshHold;

        //Next we adjust for our range
        vMotorPower = floor((vMotorPower * i_rangeMax) / (127 - i_threshHold));
      }
    }

    return vMotorPower;
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Max
//
// This procedure returns the largest of two values
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
int max(int val1, int val2)
  {
    if (val1 > val2)
      {
        return val1;
      }
    else
      {
        return val2;
      }
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Min
//
// This procedure returns the smallest of two values
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
int min(int val1, int val2)
  {
    if (val1 < val2)
      {
        return val1;
      }
    else
      {
        return val2;
      }
  }



/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Movement Control
//
// This procedure is responsible for translating the joystick readings into motor power for the
// motors responsible for moving the robot
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void movementControl()
  {
    int DriveLeftPower;
    int DriveRightPower;
    int maxMotorPower;

    //set maximum speed
    if (joy1Btn(5))
      {
        maxMotorPower = 100;
      }
    else if (joy1Btn(7))
      {
        maxMotorPower = 20;
      }
    else
      {
        maxMotorPower = 75;
      }

    //get joystick reading translate to power setting
    DriveLeftPower  = adjJoystickMotorPower(joystick.joy1_y1, maxMotorPower, 10);
    DriveRightPower = adjJoystickMotorPower(joystick.joy1_y2, maxMotorPower, 10);

    //set power for each motor
    motor[DriveRight] = DriveRightPower;
    motor[DriveLeft]  = DriveLeftPower;
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Pivot Arm
//
// This procedure is responsible for lifting the grasper into position to collect rings
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void pivotarm()
  {
  	int maxLeft = 135 + vPivotLeftBase;
  	int maxRight = 255;
  	int minLeft = 0;
  	int minRight = 120 - vPivotRightBase;

  	if (joy2Btn (6))
    {
    	vLeftPos = 68 + vPivotLeftBase;
    	vRightPos = 187 - vPivotRightBase;
    }
    else if (joy2Btn (8))
    {
    	vLeftPos = 110 + vPivotLeftBase;
    	vRightPos = 145 - vPivotRightBase;
    }
    else if (joy2Btn (5))
    {
    	vLeftPos = 0 + vPivotLeftBase;
    	vRightPos = 255 - vPivotRightBase;
    }
    else
    {
    	if (joystick.joy2_y2 > 10)
    	{
    		vLeftPos = min(vLeftPos + 1, maxLeft);
    		vRightPos = max(vRightPos - 1, minRight);
    	}
    	else if (joystick.joy2_y2 < -10)
    	{
    		vLeftPos = max(vLeftPos - 1, minLeft);
    		vRightPos = min(vRightPos + 1, maxRight);
    	}
    }

    if (joy2Btn (9))
    {
    	vPivotLeftBase = ServoValue[pivotLeft];
    	vPivotRightBase = 255 - ServoValue[pivotRight];
    }

    servo [pivotLeft] = vLeftPos;
    servo [pivotRight] = vRightPos;
  }

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Lifter Control
//
// This procedure is responsible for translating the joystick readings into motor power for the
// motors responsible for lifting and lowering the crate lifter apparatus
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void lifterControl()
  {
  	int lifterPower;
    int lifterMaxPower  = 100;
    int lifterAutoPower = 50;

    if (joy2Btn(10))
    {
    	nMotorEncoder[RightLifter1] = 0;
    }

    if(joy2Btn(1))
    {
        vliftTarget = vDispenser;

        if (abs(nMotorEncoder[RightLifter1]) < vliftTarget)
        {
            liftState = RAISING;
        }
        else if (abs(nMotorEncoder[RightLifter1]) > vliftTarget)
        {
            liftState = LOWERING;
        }
    }
    else if(joy2Btn(2))
    {
        vliftTarget = vRack1;

        if (abs(nMotorEncoder[RightLifter1]) < vliftTarget)
        {
            liftState = RAISING;
        }
        else if (abs(nMotorEncoder[RightLifter1]) > vliftTarget)
        {
            liftState = LOWERING;
        }
    }
    else if(joy2Btn(3))
    {
        vliftTarget = vRack2;

        if (abs(nMotorEncoder[RightLifter1]) < vliftTarget)
        {
            liftState = RAISING;
        }
        else if (abs(nMotorEncoder[RightLifter1]) > vliftTarget)
        {
            liftState = LOWERING;
        }
    }
    else if(joy2Btn(4))
    {
        vliftTarget = vRack3;

        if (abs(nMotorEncoder[RightLifter1]) < vliftTarget)
        {
            liftState = RAISING;
        }
        else if (abs(nMotorEncoder[RightLifter1]) > vliftTarget)
        {
            liftState = LOWERING;
        }
    }
    else
    {
        lifterPower = adjJoystickMotorPower(joystick.joy2_y1, lifterMaxPower, 10);

        if (lifterPower == 0)
        {
            if (liftState == JOYSTICK)
            {
                motor[LeftLifter1] = 0;
                motor[LeftLifter2] = 0;
                motor[RightLifter1] = 0;
                motor[RightLifter2] = 0;
                liftState = WAITING;
            }
        }
        else
        {
            liftState = JOYSTICK;

            motor[LeftLifter1] = lifterPower;
            motor[LeftLifter2] = lifterPower;
            motor[RightLifter1] = lifterPower;
            motor[RightLifter2] = lifterPower;
        }
    }

    if (liftState == RAISING)
    {
        motor[LeftLifter1] = lifterAutoPower;
        motor[LeftLifter2] = lifterAutoPower;
        motor[RightLifter1] = lifterAutoPower;
        motor[RightLifter2] = lifterAutoPower;

        if (abs(nMotorEncoder[RightLifter1]) >= vliftTarget)
        {
            motor[LeftLifter1] = 0;
            motor[LeftLifter2] = 0;
            motor[RightLifter1] = 0;
            motor[RightLifter2] = 0;
            liftState = WAITING;
        }
    }
    else if (liftState == LOWERING)
    {
        motor[LeftLifter1] = (-1) * lifterAutoPower;
        motor[LeftLifter2] = (-1) * lifterAutoPower;
        motor[RightLifter1] = (-1) * lifterAutoPower;
        motor[RightLifter2] = (-1) * lifterAutoPower;

        if (abs(nMotorEncoder[RightLifter1]) <= vliftTarget)
        {
            motor[LeftLifter1] = 0;
            motor[LeftLifter2] = 0;
            motor[RightLifter1] = 0;
            motor[RightLifter2] = 0;
            liftState = WAITING;
        }
    }
    eraseDisplay();
    nxtDisplayCenteredTextLine(1, "Enc = %i", nMotorEncoder[RightLifter1]);
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Ramp Control
//
// This procedure is responsible for controlling the motor to move the ramp down
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void RampControl()
	{
		if (joy1Btn(2))
      {
        motor[Ramp]  = 70;
      }

     else if (joy1Btn(3))
      {
        motor[Ramp] = -20;
      }
    else
      {
        motor[Ramp] = 0;
      }

    }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the tele-op robot operation.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
//   1. Loop forever repeating the following actions:
//   2. Get the latest game controller / joystick settings that have been received from the PC.
//   3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
//      simple action:
//      *  Joystick values are usually directly translated into power levels for a motor or
//         position of a servo.
//      *  Buttons are usually used to start/stop a motor or cause a servo to move to a specific
//         position.
//   4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
task main()
  {
    initializeRobot();

    waitForStart();   // wait for start of tele-op phase

    vLeftPos = 10;
    vRightPos =245;
    servo[pivotLeft] = 0;
    servo[pivotRight] = 245;

    while (true)
      {
        getJoystickSettings(joystick);
        movementControl();
        pivotarm();
        RampControl();
        lifterControl();
      }
  }
