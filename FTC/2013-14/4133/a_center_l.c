#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S2,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     mLeft,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     mRight,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     mRightArm,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     mLeftArm,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_1,     mLift,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    sIr,                  tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    sWrist,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-gyro.h"
#include "JoystickDriver.c"

const long   gcSyncInterval  = 100; //Defines the time interval between each check for collision and PID correction
const long   gcSyncTickError = 20;  //Defines how far the motors can be "off" before needing correction 50 ticks = ~12 degrees
const long   gcMotorStop = 10;
void initializeRobot()
{
	bDisplayDiagnostics = false;
	motor[mLeft] = motor[mRight] = motor[mRightArm] = motor[mLeftArm] = motor[mLift] = 0;
	servo[sWrist] = 0;
	servo[sIr] = 128;
}

void move(int iSpeed, int nTicks);

const int L_CODE = 3;
const int R_CODE = 4;

void movein(int iSpeed, float dist) {
	move(iSpeed, abs((dist-1.75)*1000.0/13.0));
}

void move(int iSpeed, int nTicks)
{
	//Set up variables
	//For the encoder tic we multiply the incoming distance by the calculated number of tics when
	//traveling one inch. To get the calculated value you must figure out the circumference of the
	//wheel, tread, etc. There are 1440 tics in a single revolution of the motor
	int  vEncoderTic   = nTicks;
	int  vPrevLeftPos  = 0;
	int  vPrevRightPos = 0;
	int  vLeftPower    = iSpeed;
	int  vRightPower   = iSpeed;
	int  vSpeed        = iSpeed;
	bool end = false;

	//Reset our encoders prior to movement
	nMotorEncoder[mLeft]  = 0;
	nMotorEncoder[mRight] = 0;

	//Start up the motors
	motor[mLeft]  = vLeftPower;
	motor[mRight] = vRightPower;

	unsigned long vNxtSyncTime  = nPgmTime + gcSyncInterval+200;

	//Loop until both motors have traveled the required distance
	while((abs(nMotorEncoder[mLeft]) < vEncoderTic || abs(nMotorEncoder[mRight]) < vEncoderTic) && !end)
	{
		//Determine the current value of the encoders
		int vCurrLeftPos  = abs(nMotorEncoder[mLeft]);
		int vCurrRightPos = abs(nMotorEncoder[mRight]);

		//We only perform error correction at specific intervals
		if (nPgmTime >= vNxtSyncTime)
		{
			nxtDisplayString(0,"%i:%i",abs(vCurrLeftPos - vPrevLeftPos),abs(vCurrRightPos - vPrevRightPos));
			if(abs(vCurrLeftPos - vPrevLeftPos) < gcMotorStop && motor[mLeft] != 0)
				end = true;

			if(abs(vCurrRightPos - vPrevRightPos) < gcMotorStop && motor[mRight] != 0)
				end = true;

			//See if we are far enough 'out of sync' to warrant speed corrections
			if (!end && abs(vCurrLeftPos - vCurrRightPos) > gcSyncTickError)
			{
				//We are out of sync. Determine which side is falling behind the other and adjust the speed
				//We default to slowing down th?e motors. The only time we speed up a motor is if it was
				//previously slowed
				if (vCurrLeftPos < vCurrRightPos)
				{
					if (vLeftPower < vSpeed)
						motor[mRight] = (vLeftPower+=2);
					else
						motor[mLeft] = (vRightPower-=2);
				}
				else
				{
					if (vRightPower < vSpeed)
						motor[mLeft] = (vRightPower+=2);
					else
						motor[mRight] = (vLeftPower-=2);
				}
			}


			//Use the interval to calculate the next sync time
			vNxtSyncTime = nPgmTime + gcSyncInterval;

			//Store the current positions in the previous position values for the next time through the loop
			vPrevLeftPos  = vCurrLeftPos;
			vPrevRightPos = vCurrRightPos;
		}

		if(abs(nMotorEncoder[mLeft]) >= vEncoderTic)
			motor[mLeft] = 0;

		if(abs(nMotorEncoder[mRight]) >= vEncoderTic)
			motor[mRight] = 0;
	}

	//We finished our movement so turn off the motors
	motor[mLeft]  = 0;
	motor[mRight] = 0;

	if(end) {
		PlaySound(soundBeepBeep);
		PlaySound(soundDownwardTones);
	}

	while(end) {
		//	continue;

		servo[sIr] = 128;
	}

	//The following line is used to pause the robot in between movements
	wait1Msec(100);
}

void turn(int iSpeed, int iDegrees, int code)
{
	float vcurrposition = 0;
	int   vprevtime     = nPgmTime;
	int   vcurrtime;
	float vcurrRate;
	int   voffset;
	float deltaSecs;
	float degChange;

	if (code == L_CODE)
	{
		motor[mLeft]  = iSpeed;
		motor[mRight] = -iSpeed;
	}
	else if(code == R_CODE)
	{
		motor[mLeft]  = -iSpeed;
		motor[mRight] = iSpeed;
	}

	while (abs(vcurrposition) < iDegrees)
	{
		// This tells us the current rate of rotation in degrees per
		// second.
		vcurrRate = HTGYROreadRot(gyro);

		// How much time has elapsed since we last checked, which we use
		// to determine how far we've turned
		vcurrtime = nPgmTime;

		deltaSecs = (vcurrtime - vprevtime) / 1000.0;
		if (deltaSecs < 0)
		{
			deltaSecs = ((float)((vcurrtime + 1024) - (vprevtime + 1024))) / 1000.0;
		}

		// Calculate how many degrees the heading changed.
		degChange = vcurrRate * deltaSecs;
		vcurrposition = vcurrposition + degChange;
		vprevtime = vcurrtime;
	}

	motor[mLeft]  = 0;
	motor[mRight] = 0;

	wait1Msec(100);
}

int b1 = 26;
int b2 = 60;
int b3 = 95;
//34
//48
//90
//113
int target = 6;

int scan() {
	int prevReg = SensorValue[ir];

	while(prevReg < target && servo[sIr] != 0) {
		prevReg = SensorValue[ir];
		servo[sIr] = servo[sIr]-1;
		wait1Msec(10);
	}
	int sPos = servo[sIr];
	nxtDisplayString(1,"%i",sPos);
	if(sPos < b1)
		return 1;
	if(sPos < b2)
		return 2;
	if(sPos < b3)
		return 3;
	return 4;
}


void followpath(int loc) {
	if(loc == 1) {
		turn(75,25,L_CODE);
		movein(50,17);
	} else if(loc == 2) {
		turn(75,13,L_CODE);
		movein(50,15.5);
	} else if(loc == 3) {
		turn(75,8,R_CODE);
		movein(50,17);
	} else {
		turn(75,19,R_CODE);
		movein(60,21);
	}
}

void dump() {
	servo[sWrist] = 100;
	wait1Msec(500);
	servo[sWrist] = 255;
	wait1Msec(150);

	motor[mLeftArm] = motor[mRightArm] = -35;
	wait1Msec(150);
	motor[mLeftArm] = motor[mRightArm] = 0;
	wait1Msec(500);

	motor[mLeftArm] = motor[mRightArm] = 50;
	wait1Msec(300);
	motor[mLeftArm] = motor[mRightArm] = 0;
	wait1Msec(300);
	servo[sWrist] = 0;
	wait1Msec(500);
}

void goOnRamp(int loc) {
	if(loc == 1) {
		turn(75,45,L_CODE);
		movein(60,23);
		turn(75,55,R_CODE);
		movein(75,35);
		turn(75,100,R_CODE);
		movein(75,35);
	} else if(loc == 2) {
		turn(75,58,L_CODE);
		movein(60,22);
		turn(75,55,R_CODE);
		movein(75,36);
		turn(75,100,R_CODE);
		movein(75,36);
	} else if(loc == 3) {
		turn(75,58,R_CODE);
		movein(60,25);
		turn(75,55,L_CODE);
		movein(75,36);
		turn(75,100,L_CODE);
		movein(75,36);
	} else {
		turn(75,45,R_CODE);
		movein(60,21);
		turn(75,55,L_CODE);
		movein(75,35);
		turn(80,100,L_CODE);
		movein(75,35);
	}
}

task main()
{
  initializeRobot();
  servoChangeRate[sWrist] = 0;
  waitForStart();

    servo[sWrist] = 125;
	motor[mLeftArm] = motor[mRightArm] = 50;
	wait1Msec(1000);
	motor[mLeftArm] = motor[mRightArm] = 0;

	servo[sIr] = 255;
  movein(50, 16);
  wait1Msec(1000);
  turn(75, 38, L_CODE);//Initial move;

  int loc = scan();
  nxtDisplayString(0,"%i",loc);
  followpath(loc);
  dump();
  goOnRamp(loc);

  //go indefinitely
  while (true) {

	servo[sIr] = 128;
      continue;
  }
}
