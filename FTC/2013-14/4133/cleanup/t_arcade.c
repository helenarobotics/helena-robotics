#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S2,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     mRight,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     mRightArm,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     mLeft,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     mLeftArm,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     mLift,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     mFlag,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    sIr,                  tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    sWrist,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c";

// Set wrist positions
const int TOP_WRIST_POS = 50;
const int BTM_WRIST_POS = 130;

const int SERVO_CENTER_POS = 128;

void arcadeDrive();
void lift();
void turnFlag();
void moveArm();
void moveWrist();
void changeSpeeds();

void saveJoyBtnState();
bool isBtnPressedJoy1(int button);
bool isBtnPressedJoy2(int button);

//Factor divided by 3 - Makes "gears" for the robot speed
//  1 - 1/3 "low" speed
//  2 - 2/3 "medium" speed
//  3 - 3/3 "high" speed
int driveSpeedFactor = 3;

void initializeRobot() {
    servoChangeRate[sWrist] = 0;
    servo[sWrist] = 0;

    servo[sIr] = SERVO_CENTER_POS;
}

task main() {
    initializeRobot();
    waitForStart();

    while (true) {
        getJoystickSettings(joystick);

        arcadeDrive();
        changeSpeeds();

        moveArm();
        moveWrist();

        lift();
        turnFlag();

        saveJoyBtnState();
    }
}

void arcadeDrive() {
    float forward = joystick.joy1_y1 / 1.28 * driveSpeedFactor / 3.00;
    float turning = joystick.joy1_x2 / 1.28 * driveSpeedFactor / 3.00;
    motor[mLeft] = forward + turning;
    motor[mRight] = forward - turning;
}

void changeSpeeds() {
    if (isBtnPressedJoy1(1))
        driveSpeedFactor = 1.5;
    else if (isBtnPressedJoy1(2))
        driveSpeedFactor = 2;
    else if (isBtnPressedJoy1(3))
        driveSpeedFactor = 3;
}

static const int ARM_JOY_THRESHOLD = 15;
void moveArm() {
    float power = joystick.joy2_y1 / 1.28;
    if (abs(power) < ARM_JOY_THRESHOLD)
        power = 0;

    // If not over-ridden with Btn5 (allowing full power), reduce
    // the power to slow down the arm (gravity) if moving down.
    if (!joy2Btn(5) && power < 0)
        power *= 0.1;

    motor[mLeftArm] = motor[mRightArm] = power;
}

// Only move the servo every 3 ms.
unsigned long wristMoveTime = 0;
const int mPsP = 3;

void moveWrist() {
    if (wristMoveTime < nPgmTime) {
        if (joy2Btn(3)) {
            servo[sWrist] = servo[sWrist] - 1;
        } else if (joy2Btn(2)) {
            servo[sWrist] = servo[sWrist] + 1;
        } else if (joy2Btn(1)) {
            servo[sWrist] = BTM_WRIST_POS;
        } else if (joy2Btn(4)) {
            servo[sWrist] = TOP_WRIST_POS;
        }
        wristMoveTime = nPgmTime + mPsP;
    }
}

void lift() {
    int liftPower = 0;
    if (joy2Btn(6))
        liftPower = 100;
    else if (joy2Btn(8))
        liftPower = -100;
    motor[mLift] = liftPower;
}

void turnFlag() {
    int flagPower = 0;
    if (joy1Btn(6))
        flagPower = 100;
    else if (joy1Btn(8))
        flagPower = -100;
    motor[mFlag] = flagPower;
}

// Keep track of the buttons on the joysticks
bool prev1[12] = {
    false, false, false, false,
    false, false, false, false,
    false, false, false, false
};
bool prev2[12] = {
    false, false, false, false,
    false, false, false, false,
    false, false, false, false
};

// Saves the state of the buttons for use in the next loop
void saveJoyBtnState() {
    for (int i = 0; i < 12; i++) {
        prev1[i] = (bool)joy1Btn(i + 1);
        prev2[i] = (bool)joy2Btn(i + 1);
    }
}

//Returns true if the button was "just" pressed
bool isBtnPressedJoy1(int button) {
    return prev1[button - 1] && joy1Btn(button);
}

bool isBtnPressedJoy2(int button) {
    return prev2[button - 1] && joy2Btn(button);
}
