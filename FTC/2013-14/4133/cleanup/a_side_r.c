#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S2,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     mRight,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     mRightArm,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     mLeft,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     mLeftArm,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_1,     mLift,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     mFlag,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    sIr,                  tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    sWrist,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "hitechnic-gyro.h"

void initializeRobot();
float findIR(int iSpeed);
void move(int iSpeed, float dist);
void movet(int iSpeed, int nTicks);
void turn(int iDegrees, int turnDir);
void goOnRamp();
void dump();
float inToTicks(float dist);
float ticksToIn(float ticks);

const float CRATE_DISTANCE = 56.0;
const float SWITCH_POINT = 22.0;


// Turn directions
const int R_DIRECTION = 3;
const int L_DIRECTION = 4;

// Defines the time interval between each check for collision and PID correction
const long gcSyncInterval = 100;

// Defines how far the motors can be "off" before needing correction
const long gcSyncTickError = 20;

const int RIGHT_IR_BORDER = 6;

void initializeRobot() {
    bDisplayDiagnostics = false;

    servo[sIr] = 128;

    servoChangeRate[sWrist] = 0;
    servo[sWrist] = 0;
}

task main()
{
    initializeRobot();
    waitForStart();

    // Lift up the arm above the crates
    servo[sWrist] = 125;
    motor[mLeftArm] = motor[mRightArm] = 50;
    wait1Msec(1000);
    motor[mLeftArm] = motor[mRightArm] = 0;

    // Scan for the beacon
    float distance = findIR(50);
    if (distance < CRATE_DISTANCE) {
        // Turn toward the crate and dump the brick
        turn(90, R_DIRECTION);
        dump();
        // Turn back straight and drive the remaining distance
        turn(80, L_DIRECTION);
        move(50, CRATE_DISTANCE - distance);
    }
    servo[sIr] = 128;
    goOnRamp();
    while (true) {
        servo[sIr] = 128;
    }
}

void dump() {
    servo[sWrist] = 100;
    wait1Msec(500);

    motor[mLeftArm] = motor[mRightArm] = -30;
    wait1Msec(200);
    motor[mLeftArm] = motor[mRightArm] = 0;
    wait1Msec(500);

    servo[sWrist] = 255;
    wait1Msec(150);

    motor[mLeftArm] = motor[mRightArm] = 50;
    wait1Msec(400);
    motor[mLeftArm] = motor[mRightArm] = 0;
    wait1Msec(500);

    servo[sWrist] = 128;
}

void goOnRamp() {
    motor[mLeftArm] = motor[mRightArm] = -30;
    wait1Msec(200);
    motor[mLeftArm] = motor[mRightArm] = 0;

    turn(60, R_DIRECTION);
    move(60, 42);
    turn(100, R_DIRECTION);
    move(60, 40);
    //PlaySoundFile("zeld_ow_001.rso");
}

const int TURN_POWER = 55;
void turn(int iDegrees, int turnDir)
{
    // How much over-run in degrees do we have?
    iDegrees -= 5;

    switch (turnDir) {
    case L_DIRECTION:
        motor[mLeft] = -TURN_POWER;
        motor[mRight] = TURN_POWER;
        break;

    case R_DIRECTION:
    default:
        motor[mLeft] = TURN_POWER;
        motor[mRight] = -TURN_POWER;
    }

    long vprevtime = nPgmTime;

    float vcurrposition = 0;
    while (vcurrposition < iDegrees)
    {
        // This tells us the current rate of rotation in degrees per
        // second.
        float vcurrRate = abs(HTGYROreadRot(gyro));

        // Calculate how much time has elapsed since we last checked,
        // which we use to determine how far we've turned
        long vcurrtime = nPgmTime;
        float deltaSecs = (vcurrtime - vprevtime) / 1000.0;

        // Calculate how many degrees the heading changed.
        float degChange = vcurrRate * deltaSecs;
        vcurrposition = vcurrposition + degChange;

        vprevtime = vcurrtime;
        EndTimeSlice();
    }

    motor[mLeft] = 0;
    motor[mRight] = 0;

    wait1Msec(100);
}

void move(int iSpeed, float dist) {
    movet(iSpeed, abs((dist - 1.75) * 1000.0 / 13.0));
}

void movet(int iSpeed, int nTicks)
{
    int vLeftPower = iSpeed;
    int vRightPower = iSpeed;
    int vPrevLeftPos = 0;
    int vPrevRightPos = 0;

    // Reset our encoders prior to movement
    nMotorEncoder[mLeft] = 0;
    nMotorEncoder[mRight] = 0;

    // Start up the motors
    motor[mLeft] = vLeftPower;
    motor[mRight] = vRightPower;

    unsigned long vNxtSyncTime = nPgmTime + gcSyncInterval;

    // Determine the current value of the encoders
    int vCurrLeftPos = abs(nMotorEncoder[mLeft]);
    int vCurrRightPos = abs(nMotorEncoder[mRight]);

    // Loop until both motors have traveled the required distance
    while (vCurrLeftPos < nTicks || vCurrRightPos < nTicks)
    {
        // Turn off the motor if we've reached the target value.
        if (vCurrLeftPos >= nTicks)
            motor[mLeft] = 0;
        if (vCurrRightPos >= nTicks)
            motor[mRight] = 0;

        // Perform error correction at specific intervals
        if (nPgmTime >= vNxtSyncTime)
        {
            nxtDisplayString(0,"%i:%i", abs(vCurrLeftPos - vPrevLeftPos), abs(vCurrRightPos - vPrevRightPos));

            // See if we are far enough 'out of sync' to warrant speed
            // corrections
            if (abs(vCurrLeftPos - vCurrRightPos) > gcSyncTickError)
            {
                // We are out of sync. Determine which side is falling
                // behind the other and adjust the speed.  We default to
                // slowing down the motors.  The only time we speed up a
                // motor is if the other side previously slowed.
                if (vCurrLeftPos < vCurrRightPos)
                {
                    // Left is ahead, slow it down or speedup right?
                    if (vRightPower >= iSpeed)
                        vRightPower--;
                    else
                        vLeftPower++;
                }
                else
                {
                    if (vLeftPower >= iSpeed)
                        vLeftPower--;
                    else
                        vRightPower++;
                }
                motor[mLeft] = vLeftPower;
                motor[mRight] = vRightPower;
            }

            // XXX - Motor safety not enabled

            // Store the current positions in the previous position values for the next time through the loop
            vPrevLeftPos = vCurrLeftPos;
            vPrevRightPos = vCurrRightPos;

            // Use the interval to calculate the next sync time
            vNxtSyncTime = nPgmTime + gcSyncInterval;
        }

        EndTimeSlice();

        // Obtain the latest encoder positions
        vCurrLeftPos = abs(nMotorEncoder[mLeft]);
        vCurrRightPos = abs(nMotorEncoder[mRight]);
    }

    //We finished our movement so turn off the motors
    motor[mLeft] = motor[mRight] = 0;

    //The following line is used to pause the robot in between movements
    wait1Msec(100);
}

bool foundBeacon = false;
task IRTask()
{
    // Wait for the servo to get to the correct position first.
    servo[sIr] = 220;
    wait1Msec(1000);

    while (!foundBeacon) {
        EndTimeSlice();
        foundBeacon = (SensorValue[ir] == RIGHT_IR_BORDER);
    }
}

float findIR(int iSpeed) {
    int vLeftPower = iSpeed;
    int vRightPower = iSpeed;
    int vPrevLeftPos = 0;
    int vPrevRightPos = 0;

    // Setup the IR beacon searcher
    StartTask(IRTask);
    wait1Msec(1000);

    // Reset our encoders prior to movement
    nMotorEncoder[mLeft] = 0;
    nMotorEncoder[mRight] = 0;

    // Start up the motors
    motor[mLeft] = vLeftPower;
    motor[mRight] = vRightPower;

    unsigned long vNxtSyncTime = nPgmTime + gcSyncInterval;

    // Determine the current value of the encoders
    int vCurrLeftPos = abs(nMotorEncoder[mLeft]);
    int vCurrRightPos = abs(nMotorEncoder[mRight]);

    // Loop until both motors have traveled the required distance or
    // we locate the beacon
    int nTicks = abs(inToTicks(CRATE_DISTANCE));
    while (!foundBeacon && (vCurrLeftPos < nTicks || vCurrRightPos < nTicks))
    {
        // Turn off the motor if we've reached the target value.
        if (vCurrLeftPos >= nTicks)
            motor[mLeft] = 0;
        if (vCurrRightPos >= nTicks)
            motor[mRight] = 0;

        nxtDisplayString(0,"%i", abs(vCurrLeftPos - vCurrRightPos));

        if (ticksToIn((vCurrLeftPos + vCurrRightPos) / 2) >= SWITCH_POINT)
            servo[sIr] = 210;

        // Perform error correction at specific intervals
        if (nPgmTime >= vNxtSyncTime)
        {
            // See if we are far enough 'out of sync' to warrant speed
            // corrections
            if (abs(vCurrLeftPos - vCurrRightPos) > gcSyncTickError)
            {
                // We are out of sync. Determine which side is falling
                // behind the other and adjust the speed.  We default to
                // slowing down the motors.  The only time we speed up a
                // motor is if the other side previously slowed.
                if (vCurrLeftPos < vCurrRightPos)
                {
                    // Left is ahead, slow it down or speedup right?
                    if (vRightPower >= iSpeed)
                        vRightPower -= 2;
                    else
                        vLeftPower += 2;
                }
                else
                {
                    if (vLeftPower >= iSpeed)
                        vLeftPower -= 2;
                    else
                        vRightPower += 2;
                }
                motor[mLeft] = vLeftPower;
                motor[mRight] = vRightPower;
            }

            // XXX - Motor safety not enabled

            // Store the current positions in the previous position values for the next time through the loop
            vPrevLeftPos = vCurrLeftPos;
            vPrevRightPos = vCurrRightPos;

            // Use the interval to calculate the next sync time
            vNxtSyncTime = nPgmTime + gcSyncInterval;
        }

        EndTimeSlice();

        // Obtain the latest encoder positions
        vCurrLeftPos = abs(nMotorEncoder[mLeft]);
        vCurrRightPos = abs(nMotorEncoder[mRight]);
    }

    //We finished our movement so turn off the motors
    motor[mLeft] = motor[mRight] = 0;
    wait1Msec(100);

    return ticksToIn(vCurrLeftPos + vCurrRightPos) / 2;
}

float inToTicks(float dist) {
    return (dist - 1.75) * 1000.0 / 13.0;
}

float ticksToIn(float ticks) {
    return 13.0 * ticks / 1000.0;
}
