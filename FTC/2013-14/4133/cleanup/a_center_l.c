#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S2,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     mRight,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     mRightArm,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     mLeft,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     mLeftArm,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_1,     mLift,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     mFlag,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    sIr,                  tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    sWrist,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-gyro.h"
#include "JoystickDriver.c"

// What is the center position of the servo
const int IR_SERVO_CENTER_POS = 128;
const int IR_SERVO_START_SCAN_POS = 255;

// Defines the time interval between each check for collision and PID correction
const long gcSyncInterval = 100;

// Defines how far the motors can be "off" before needing correction
const long gcSyncTickError = 20;

void initializeRobot()
{
    bDisplayDiagnostics = false;
    motor[mLeft] = motor[mRight] = motor[mRightArm] = motor[mLeftArm] = motor[mLift] = 0;

    servoChangeRate[sWrist] = 0;
    servo[sWrist] = 0;

    servo[sIr] = IR_SERVO_CENTER_POS;
}

void move(int iSpeed, int nTicks);

const int L_DIRECTION = 3;
const int R_DIRECTION = 4;

void movein(int iSpeed, float distIn) {
    //For the encoder ticks we multiply the incoming distance by the calculated number of ticks when
    //traveling one inch. To get the calculated value you must figure out the circumference of the
    //wheel, tread, etc. There are 1440 ticks in a single revolution of the motor
    move(iSpeed, abs((distIn - 1.75) * 1000.0 / 13.0));
}

void move(int iSpeed, int nTicks)
{
    int vLeftPower = iSpeed;
    int vRightPower = iSpeed;
    int vPrevLeftPos = 0;
    int vPrevRightPos = 0;

    // Reset our encoders prior to movement
    nMotorEncoder[mLeft] = 0;
    nMotorEncoder[mRight] = 0;

    // Start up the motors
    motor[mLeft] = vLeftPower;
    motor[mRight] = vRightPower;

    unsigned long vNxtSyncTime = nPgmTime + gcSyncInterval;

    // Determine the current value of the encoders
    int vCurrLeftPos = abs(nMotorEncoder[mLeft]);
    int vCurrRightPos = abs(nMotorEncoder[mRight]);

    // Loop until both motors have traveled the required distance
    while (vCurrLeftPos < nTicks || vCurrRightPos < nTicks)
    {
        // Turn off the motor if we've reached the target value.
        if (vCurrLeftPos >= nTicks)
            motor[mLeft] = 0;
        if (vCurrRightPos >= nTicks)
            motor[mRight] = 0;

        // Perform error correction at specific intervals
        if (nPgmTime >= vNxtSyncTime)
        {
            nxtDisplayString(0,"%i:%i", abs(vCurrLeftPos - vPrevLeftPos), abs(vCurrRightPos - vPrevRightPos));

            // See if we are far enough 'out of sync' to warrant speed
            // corrections
            if (abs(vCurrLeftPos - vCurrRightPos) > gcSyncTickError)
            {
                // We are out of sync. Determine which side is falling
                // behind the other and adjust the speed.  We default to
                // slowing down the motors.  The only time we speed up a
                // motor is if the other side previously slowed.
                if (vCurrLeftPos < vCurrRightPos)
                {
                    // Left is ahead, slow it down or speedup right?
                    if (vRightPower >= iSpeed)
                        vRightPower -= 2;
                    else
                        vLeftPower += 2;
                }
                else
                {
                    if (vLeftPower >= iSpeed)
                        vLeftPower -= 2;
                    else
                        vRightPower += 2;
                }
                motor[mLeft] = vLeftPower;
                motor[mRight] = vRightPower;
            }

            // XXX - Motor safety not enabled

            // Store the current positions in the previous position values for the next time through the loop
            vPrevLeftPos = vCurrLeftPos;
            vPrevRightPos = vCurrRightPos;

            // Use the interval to calculate the next sync time
            vNxtSyncTime = nPgmTime + gcSyncInterval;
        }

        EndTimeSlice();

        // Obtain the latest encoder positions
        vCurrLeftPos = abs(nMotorEncoder[mLeft]);
        vCurrRightPos = abs(nMotorEncoder[mRight]);
    }

    //We finished our movement so turn off the motors
    motor[mLeft] = motor[mRight] = 0;

    //The following line is used to pause the robot in between movements
    wait1Msec(100);
}

const int TURN_POWER = 55;

void turn(int iDegrees, int turnDir)
{
    // Allow for over-run which occurs when we turn-off motors (not calculated,
    // just a WAG based on analyzing the program).
    iDegrees -=5;

    switch (turnDir) {
    case L_DIRECTION:
        motor[mLeft] = -TURN_POWER;
        motor[mRight] = TURN_POWER;
        break;

    case R_DIRECTION:
    default:
        motor[mLeft] = TURN_POWER;
        motor[mRight] = -TURN_POWER;
    }

    long vprevtime = nPgmTime;

    float vcurrposition = 0;
    while (vcurrposition < iDegrees)
    {
        // This tells us the current rate of rotation in degrees per
        // second.
        float vcurrRate = abs(HTGYROreadRot(gyro));

        // Calculate how much time has elapsed since we last checked,
        // which we use to determine how far we've turned
        long vcurrtime = nPgmTime;
        float deltaSecs = (vcurrtime - vprevtime) / 1000.0;

        // Calculate how many degrees the heading changed.
        float degChange = vcurrRate * deltaSecs;
        vcurrposition = vcurrposition + degChange;

        vprevtime = vcurrtime;
        EndTimeSlice();
    }

    motor[mLeft] = 0;
    motor[mRight] = 0;

    wait1Msec(100);
}

// Servo positions that determine the location of the
// IR beacon.
const int b1 = 35;
const int b2 = 73;
const int b3 = 109;

int SENSOR_TARGET = 6;

int scan() {
    int prevReg = SensorValue[ir];
    while (prevReg < SENSOR_TARGET && servo[sIr] > 0) {
        // XXX - Bug, the sensor should be read after waiting for the
        // servo to move, but changing it will affect the calculate
        // servo positions.
        prevReg = SensorValue[ir];
        servo[sIr] = servo[sIr] - 1;
        wait1Msec(10);
    }
    int sPos = servo[sIr];

    servo[sIr] = IR_SERVO_CENTER_POS;

    if (sPos < b1)
        return 1;
    if (sPos < b2)
        return 2;
    if (sPos < b3)
        return 3;
    else
        return 4;
}


void followPath(int beaconLoc) {
    switch (beaconLoc) {
    case 1:
        turn(30, L_DIRECTION);
        movein(55, 17);
        break;

    case 2:
        turn(13, L_DIRECTION);
        movein(55, 15.5);
        break;

    case 3:
        turn(13, R_DIRECTION);
        movein(55, 16);
        break;

    case 4:
    default:
        turn(25, R_DIRECTION);
        movein(55, 19);
        break;
    }
}

void dump() {
    servo[sWrist] = 100;
    wait1Msec(500);
    servo[sWrist] = 255;
    wait1Msec(150);

    motor[mLeftArm] = motor[mRightArm] = -35;
    wait1Msec(150);
    motor[mLeftArm] = motor[mRightArm] = 0;
    wait1Msec(500);

    motor[mLeftArm] = motor[mRightArm] = 50;
    wait1Msec(300);
    motor[mLeftArm] = motor[mRightArm] = 0;
    wait1Msec(300);
    servo[sWrist] = 0;
    wait1Msec(500);
}

void goOnRamp(int beaconLoc) {
    switch (beaconLoc) {
    case 1:
        turn(50, L_DIRECTION);
        movein(53, 23);
        turn(60, R_DIRECTION);
        movein(55, 35);
        turn(110, R_DIRECTION);
        movein(70, 35);
        break;

    case 2:
        turn(67, L_DIRECTION);
        movein(55, 24);
        turn(60, R_DIRECTION);
        movein(55, 36);
        turn(105, R_DIRECTION);
        movein(70, 36);
        break;

    case 3:
        turn(63, R_DIRECTION);
        movein(55, 27);
        turn(62, L_DIRECTION);
        movein(55, 38);
        turn(105, L_DIRECTION);
        movein(70, 38);
        break;

    case 4:
    default:
        turn(50, R_DIRECTION);
        movein(55, 21);
        turn(60, L_DIRECTION);
        movein(55, 35);
        turn(105, L_DIRECTION);
        movein(70, 35);
        break;
    }
}

task main()
{
    initializeRobot();
    waitForStart();

    // Lift up the arm above the crates
    servo[sWrist] = 125;
    motor[mLeftArm] = motor[mRightArm] = 50;
    wait1Msec(1000);
    motor[mLeftArm] = motor[mRightArm] = 0;

    // Get ready to scan for the beacon, and move away from
    // the start position
    servo[sIr] = IR_SERVO_START_SCAN_POS;
    movein(55, 17);
    wait1Msec(1000);
    turn(45, L_DIRECTION);

    // Find the IR beacon, move to the appropriate crate, and then dump
    // the brick.
    int beaconLoc = scan();
    nxtDisplayString(3, "%i", beaconLoc);
    followPath(beaconLoc);
    dump();

    // Move onto the ramp
    goOnRamp(beaconLoc);
    PlaySoundFile("zeld_ow_001.rso");

    //go indefinitely
    while (true) {
        servo[sIr] = IR_SERVO_CENTER_POS;
        continue;
    }
}
