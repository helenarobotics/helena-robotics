#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S3,     irSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     DriveLeft,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Ramp,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     LeftLifter1,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     LeftLifter2,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     DriveRight,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     motorA,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     RightLifter1,  tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C2_2,     RightLifter2,  tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C3_1,    IR,                   tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    pivotLeft,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    pivotRight,           tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "drivers/hitechnic-gyro.h"

const int  vThreshHold    = 5;
const long vSyncInterval  = 250;
const long vSyncTickError = 50;

int    gReady = 0;
string gRun   = "BeaconRing";
string gSide = "left";
int gPos   = 1;
int gPath = 1;
int gHeight = 1;

typedef enum
{
  FORWARD,
  BACKWARD,
  LEFT,
  RIGHT,
} cmdState;

typedef enum
{
  UP,
  DOWN,
} liftState;

task ButtonTask()
{
 	nSchedulePriority = kHighPriority;

  switch(nNxtButtonPressed)
  {
    case kLeftButton:
    if (gReady == 0)
    {
      if (strcmp(gRun, "BeaconRing")== 0)
      {
        gRun = "CDefense";
      }
      else if (strcmp(gRun, "CDefense")== 0)
      {
        gRun = "Defense";
      }
    	else if (strcmp(gRun, "Defense")== 0)
      {
        gRun = "PlaceRing";
      }
      else if (strcmp(gRun, "PlaceRing")== 0)
      {
        gRun = "BeaconRing";
      }

      nxtDisplayTextLine(2, gRun);
     }
       else if (gReady == 1)
       {
         if (strcmp(gSide, "left")== 0)
         {
           gSide = "right";
         }
         else
         {
           gSide = "left";
         }

         nxtDisplayTextLine(3, "Side: %s", gSide);
        }
       	else if (gReady == 2)
        {
          gPos--;
          if (gPos<1)
          {
            gPos=3;
          }

          nxtDisplayTextLine(4, "Position: %i", gPos);
         }
    		 else if (gReady == 3)
         {
           gPath--;
           if (gPath<1)
           {
             gPath=3;
           }

           nxtDisplayTextLine(5, "Column: %i", gPath);
          }
          else if (gReady == 4)
          {
            gHeight--;
            if (gHeight<1)
           	{
             	gHeight=3;
            }

            nxtDisplayTextLine(6, "Row: %i", gHeight);
          }

        break;
        case kRightButton:
        if (gReady == 0)
        {
         	if (strcmp(gRun, "BeaconRing")== 0)
          {
            gRun = "PlaceRing";
          }
          else if (strcmp(gRun, "PlaceRing")== 0)
          {
            gRun = "Defense";
          }
          else if (strcmp(gRun, "Defense")== 0)
          {
            gRun = "CDefense";
          }
          else if (strcmp(gRun, "CDefense")== 0)
          {
            gRun = "BeaconRing";
          }

          nxtDisplayTextLine(2, gRun);
         }
        	else if (gReady == 1)
          {
            if (strcmp(gSide, "left")== 0)
            {
                  gSide = "right";
                }
              else
                {
                  gSide = "left";
                }

              nxtDisplayTextLine(3, "Side: %s", gSide);
            }
          else if (gReady == 2)
            {
             gPos++;
             if (gPos>3)
             {
               gPos=1;
             }

              nxtDisplayTextLine(4, "Position: %i", gPos);
            }
        else if (gReady == 3)
            {
             gPath++;
             if (gPath>3)
             {
               gPath=1;
             }

              nxtDisplayTextLine(5, "Column: %i", gPath);
            }
         else if (gReady == 4)
            {
             gHeight++;
             if (gHeight>3)
             {
               gHeight=1;
             }

              nxtDisplayTextLine(6, "Row: %i", gHeight);
            }


          break;
        case kEnterButton:
          gReady = gReady + 1;

          if (gReady == 1)
            {
              nxtDisplayTextLine(3, "Side: %s", gSide);
            }
          else if (gReady == 2)
            {
              nxtDisplayTextLine(4, "Position: %i", gPos);
            }
          else if (gReady == 3)
          	{
          		nxtDisplayTextLine(5, "Column: %i", gPath);
						}
					else if (gReady == 4)
						{
							nxtDisplayTextLine(6, "Row: %i", gHeight);
						}

          break;
        case kExitButton:
          gReady = gReady - 1;

          if (gReady < 0)
            {
              gReady = 0;
            }

          if (gReady == 0)
            {
              nxtDisplayClearTextLine(3);
            }
          else if (gReady == 1)
            {
              nxtDisplayClearTextLine(4);
            }
          else if (gReady == 2)
          	{
          		nxtDisplayClearTextLine(5);
          	}
          else if (gReady == 3)
          	{
          		nxtDisplayClearTextLine(6);
          	}

          break;
      }

    return;
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void initializeRobot()
  {
  	servo[pivotLeft] = 0;
  	servo[pivotRight] = 255;

  	disableDiagnosticsDisplay();
    // Place code here to initialize servos to starting positions.
    // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
    eraseDisplay();
    nxtDisplayCenteredTextLine(1, "Autonomous");
    nxtDisplayTextLine(2, gRun);

    nNxtButtonTask = ButtonTask;
    nNxtExitClicks = 2;

    while (gReady < 5)
    {
      //Do nothing. This loop puts us in a wait mode while a team member selects the program,
      //alliance color, and position of the robot
    }

    nxtDisplayCenteredTextLine(7, "READY");

    //Calibrate the gyro sensor while the robot is still
    HTGYROstartCal(gyro);
    wait1Msec(1000);

    if (strcmp(gSide, "left")== 0)
    {
    	servo[IR] = 50;
  	}
  	else
  	{
  		servo[IR] = 175;
  	}

  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    move
//
// This is a generic movement routine that handles turning the motors on and off as well as
// watching encoder values to detect when movement is impaired.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void move(int speed, int vdistance, cmdState cmd)
  {
    int  vPrevLeftPos  = 0;
    int  vPrevRightPos = 0;
    int  vCurrLeftPos  = 0;
    int  vCurrRightPos = 0;
    int  vLeftPower    = speed;
    int  vRightPower   = speed;
    int  vRightOffset  = 1;
    int  vLeftOffset   = 1;
    long vNxtSyncTime  = nPgmTime + vSyncInterval;
    int vEncoderTic = 115 * vdistance;
    int vSpeed = speed;

    //Set our motor offsets based on the supplied command
    switch (cmd)
    {
      case FORWARD:
      //To move forward both motor powers should be positive
      vRightOffset = 1;
      vLeftOffset  = 1;
      break;
      case BACKWARD:
      //To move backward both motor powers should be negative
      vRightOffset = -1;
      vLeftOffset  = -1;
      break;
      case LEFT:
      //To turn left, the left motor must run backward and the right motor forward
      vRightOffset = 1;
      vLeftOffset  = -1;
      break;
     	case RIGHT:
      //To turn right, the right motor must run backward and the left motor forward
      vRightOffset = -1;
      vLeftOffset  = 1;
      break;
    }

    //Reset our encoders prior to movement
    nMotorEncoder[DriveLeft]  = 0;
    nMotorEncoder[DriveRight] = 0;

    //Start up the motors
    motor[DriveLeft]  = vLeftPower * vLeftOffset;
    motor[DriveRight] = vRightPower * vRightOffset;

    //Loop until both motors have traveled the required distance
    while(abs(nMotorEncoder[DriveLeft]) < vEncoderTic || abs(nMotorEncoder[DriveRight]) < vEncoderTic)
    {
      //Determine the current value of the encoders
      vCurrLeftPos  = abs(nMotorEncoder[DriveLeft]);
      vCurrRightPos = abs(nMotorEncoder[DriveRight]);

      //We only perform error correction at specific intervals
      if (nPgmTime >= vNxtSyncTime)
      {
      	//See if we are far enough 'out of sync' to warrant speed corrections
        //To do this, we average the encoder values and then compare each individual motor to that average
        int avg = (vCurrLeftPos + vCurrRightPos) / 2;

        if (abs(vCurrLeftPos - avg) > vSyncTickError || abs(vCurrRightPos - avg) > vSyncTickError)
        {
          //We are out of sync. Determine which side is falling behind the other and adjust the speed
          //We default to slowing down the motors. The only time we speed up a motor is if it was
         	//previously slowed
          if (vCurrLeftPos < vCurrRightPos)
          {
            if (vLeftPower < vSpeed)
            {
              vLeftPower       = vLeftPower + 1;
              motor[DriveLeft] = vLeftPower * vLeftOffset;
            }
            else
            {
              vRightPower       = vRightPower - 1;
              motor[DriveRight] = vRightPower * vRightOffset;
            }
           }
           else
           {
              if (vRightPower < vSpeed)
              {
                 vRightPower       = vRightPower + 1;
                 motor[DriveRight] = vRightPower * vRightOffset;
              }
              else
              {
                  vLeftPower       = vLeftPower - 1;
                  motor[DriveLeft] = vLeftPower * vLeftOffset;
               }
             }
           }

           //Now we check to ensure we have not run into an object preventing us from moving.
           if ((vCurrLeftPos <= (vPrevLeftPos + vThreshHold)) || (vCurrRightPos <= (vPrevRightPos + vThreshHold)))
          	{
             	//At least one motor is stuck. Turn off motors and wait for a period of time to avoid motor burn out.
              motor[DriveLeft]  = 0;
              motor[DriveRight] = 0;

              wait1Msec(1000);

              motor[DriveLeft]  = 50 * vLeftOffset;
              motor[DriveRight] = 50 * vRightOffset;
              vSpeed = 50;
            }

            vNxtSyncTime = nPgmTime + vSyncInterval;

            vPrevLeftPos  = vCurrLeftPos;
            vPrevRightPos = vCurrRightPos;
          }
      }

    motor[DriveLeft]  = 0;
    motor[DriveRight] = 0;

    //The following line is used to pause the robot in between movements
    wait1Msec(100);
  }
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    move lift
//
// This is a generic movement routine that handles turning the motors on and off as well as
// watching encoder values to detect when movement is impaired.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void moveLift(int speed, int vdistance, liftState cmd)
  {
    int  vPrevPos  = 0;
    int  vCurrPos  = 0;
    int vOffset;
    long vNxtSyncTime  = nPgmTime + vSyncInterval;
    long vEncoderTic = abs(vdistance);

    //Set our motor offsets based on the supplied command
    switch (cmd)
    {
      case UP:
      //To move forward both motor powers should be positive
      vOffset = 1;
      break;
      case DOWN:
      //To move backward both motor powers should be negative
      vOffset = -1;
      break;
    }

    //Reset our encoders prior to movement
    nMotorEncoder[RightLifter1]  = 0;

    //Start up the motors
    motor[LeftLifter1]  = speed * vOffset;
    motor[LeftLifter2] = speed * vOffset;
    motor[RightLifter1]  = speed * vOffset;
    motor[RightLifter2] = speed * vOffset;

    //Loop until both motors have traveled the required distance
    while(abs(nMotorEncoder[RightLifter1]) < vEncoderTic)
    {
      //Determine the current value of the encoders
     	vCurrPos  = abs(nMotorEncoder[RightLifter1]);

      //We only perform error correction at specific intervals
      if (nPgmTime >= vNxtSyncTime)
      {
        //Now we check to ensure we have not run into an object preventing us from moving.
        if (vCurrPos <= (vPrevPos + vThreshHold))
        {
          //At least one motor is stuck. Turn off motors and wait for a period of time to avoid motor burn out.
          motor[LeftLifter1]  = 0;
          motor[LeftLifter2] = 0;
          motor[RightLifter1]  = 0;
          motor[RightLifter2] = 0;

          wait1Msec(1000);

          motor[LeftLifter1]  = speed * vOffset;
          motor[LeftLifter2] = speed * vOffset;
          motor[RightLifter1]  = speed * vOffset;
          motor[RightLifter2] = speed * vOffset;
         }

         vNxtSyncTime = nPgmTime + vSyncInterval;

         vPrevPos  = vCurrPos;
        }
      }

    	motor[LeftLifter1]  = 0;
    	motor[LeftLifter2] = 0;
    	motor[RightLifter1]  = 0;
    	motor[RightLifter2] = 0;

    	//The following line is used to pause the robot in between movements
    	wait1Msec(100);
  }

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    GyroTurn
//
// This is a generic movement routine turns the robot a specific number of degrees using a gyro
// sensor to measure angular velocity
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void GyroTurn(int vspeed, int vdegrees, cmdState cmd)
  {
    float vcurrposition = 0;
    int vprevtime = nPgmTime;
    int vcurrtime;
    float vcurrRate;
    int voffset;
    float deltaSecs;
    float degChange;

    if (cmd == LEFT)
    {
      motor[DriveLeft]  = -1*vspeed;
      motor[DriveRight] = vspeed;
      voffset = -1;
    }
    else
    {
     	motor[DriveLeft]  = vspeed;
      motor[DriveRight] = -1*vspeed;
      voffset = 1;
    }

    while (vcurrposition < vdegrees)
    {
      // This tells us the current rate of rotation in degrees per
      // second.
      vcurrRate = HTGYROreadRot(gyro)*voffset;

      // How much time has elapsed since we last checked, which we use
      // to determine how far we've turned
      vcurrtime = nPgmTime;

      deltaSecs = (vcurrtime - vprevtime) / 1000.0;
      if (deltaSecs < 0)
      {
        deltaSecs = ((float)((vcurrtime + 1024) - (vprevtime + 1024))) / 1000.0;
      }

      // Calculate how many degrees the heading changed.
      degChange = vcurrRate * deltaSecs;
      vcurrposition = vcurrposition + degChange;
			vprevtime = vcurrtime;
     }

    motor[DriveLeft]  = 0;
    motor[DriveRight] = 0;

    //The following line is used to pause the robot in between movements
    wait1Msec(100);
  }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    findBeacon
//
// This routine uses the IR seeker sensor to orient the robot based on the IR beacon
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
int findBeacon(int vpos, string vside)
  {
  	int SensorVal1;
  	//int SensorVal2;
  	int BeaconPos;

    eraseDisplay();

		//First we must turn the robot until the beacon is in front of us
    if (strcmp(vside, "left")== 0)
    {
    	nxtDisplayCenteredTextLine(5, "Left");
  		while (SensorValue[irSeeker] < 7 && ServoValue[IR] < 255)
      {
        servo[IR] = ServoValue[IR] + 1;
      }
		}
		else
		{
    	nxtDisplayCenteredTextLine(5, "Right");
  		while (SensorValue[irSeeker] > 3 && ServoValue[IR] > 0)
      {
        servo[IR] = ServoValue[IR] - 1;
      }
		}

    SensorVal1 = ServoValue[IR];

    BeaconPos = ServoValue[IR];

    //servo[IR] = 15;

    nxtDisplayCenteredTextLine(1, "Beacon Found");
    nxtDisplayTextLine(3, "%i",BeaconPos);

    //wait10Msec (10000);

    if (vpos == 1)
    {
    	if (strcmp(vside, "left")== 0)
    	{
    		if (BeaconPos < 78)
    		{
    			return 1;
    		}
    		else if (BeaconPos < 97)
    		{
    			return 2;
    		}
    		else
    		{
    			return 3;
    		}
    	}
    	else
    	{
    		if (BeaconPos < 94)
    		{
    			return 3;
    		}
    		else if (BeaconPos < 114)
    		{
    			return 2;
    		}
    		else
    		{
    			return 1;
    		}
    	}
    }
    else if (vpos == 2)
    {
    	if (strcmp(vside, "left")== 0)
    	{
    		if (BeaconPos < 91)
    		{
    			return 1;
    		}
    		else if (BeaconPos < 114)
    		{
    			return 2;
    		}
    		else
    		{
    			return 3;
    		}
    	}
    	else
    	{
    		if (BeaconPos < 78)
    		{
    			return 3;
    		}
    		else if (BeaconPos < 103)
    		{
    			return 2;
    		}
    		else
    		{
    			return 1;
    		}
    	}
    }
    else
   	{
    	return 1;
   	}

  }

//////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Path 1
//
// Move forward, turn to closest side of rack, move forward, turn towards rack
//
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////
  void path1 (string vside, int vdist1, int vdist2)
  	{
  		move (50,12,FORWARD);
  		if (strcmp(vside, "left")== 0)
      {
        GyroTurn (50, 90, LEFT);
      }
   		else
      {
        GyroTurn (50, 90, RIGHT);
      }
  		move (50,vdist1,FORWARD);
  		if (strcmp(vside, "left")== 0)
      {
        GyroTurn (50, 45, RIGHT);
      }
    	else
      {
        GyroTurn (50, 45, LEFT);
      }
  		move (40,vdist2,FORWARD);
  	}





//////////////////////////////////////////////////////////////////////////////////////////////////
//                                       Path 2
//
// Drive straight, turn toward rack
//
//
//
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////
void path2 (string vside, int vdist1, int vdist2)
  {
  	move (50,vdist1,FORWARD);
 		if (strcmp(vside, "left")== 0)
    {
      GyroTurn (50, 45, LEFT);
    }
    else
    {
      GyroTurn (50, 45, RIGHT);
    }
 		move (50,vdist2,FORWARD);
 	}

//////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Path 3
//
// Move forward, turn to farthest side of rack, move forward, turn to rack
//
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////
void path3 (string vside, int vdist)
  {
 		move (50,15,FORWARD);
 		if (strcmp(vside, "left")== 0)
    {
      GyroTurn (50, 45, RIGHT);
    }
    else
    {
      GyroTurn (50, 45, LEFT);
    }
 		move (50,vdist,FORWARD);
 	  if (strcmp(vside, "left")== 0)
    {
      GyroTurn (50, 90, LEFT);
    }
    else
    {
      GyroTurn (50, 90, RIGHT);
    }
    move (50, 22, FORWARD);
 	}


//////////////////////////////////////////////////////////////////////////////////////////////////
//                                       place ring
//
// Place autonomous ring while sensing the Ir beacon
//
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////
void placering (string vside, int vpos, int vcolumn, int vheight)
{
	if (vcolumn == 2)
	{
		moveLift (0, 0, UP);
	}
	else
	{
		if (vheight == 1)
		{
			moveLift(40, 571, UP);
		}
		else if (vheight == 2)
		{
			moveLift(40, 3095, UP);
		}
		else if (vheight == 3)
		{
			moveLift(40, 5233, UP);
		}
	}

	if (vpos == 1)
	{
		if (vcolumn == 1)
		{
			path1 (vside,33, 15);
		}
		else if (vcolumn == 2)
		{
			move(50, 16, FORWARD);

			if (strcmp(vside, "left")== 0)
      {
        GyroTurn (50, 45, LEFT);
      }
    	else
      {
        GyroTurn (50, 45, RIGHT);
      }

			move(50, 21, FORWARD);

			if (strcmp(vside, "left")== 0)
      {
        GyroTurn (50, 45, LEFT);
      }
    	else
      {
        GyroTurn (50, 45, RIGHT);
      }
			move(50, 13, FORWARD);

			if (strcmp(vside, "left")== 0)
      {
       	GyroTurn (50, 30, RIGHT);
      }
    	else
      {
        GyroTurn (50, 30, LEFT);
      }

			move(50, 1, BACKWARD);

			moveLift(40, 500, UP);

			move(50, 3, FORWARD);
		}
		else if (vcolumn == 3)
		{
			path2 (vside, 20, 31);
		}
	}
	else if (vpos == 2)
	{
		if (vcolumn == 1)
		{
			path1 (vside, 15, 12);
		}
		else if (vcolumn == 2)
		{
			move(50, 33, FORWARD);

			if (strcmp(vside, "left")== 0)
      {
        GyroTurn (50, 90, LEFT);
      }
    	else
      {
        GyroTurn (50, 90, RIGHT);
      }

			move(50, 19, FORWARD);

			if (strcmp(vside, "left")== 0)
      {
       	GyroTurn (50, 30, RIGHT);
      }
    	else
      {
        GyroTurn (50, 30, LEFT);
      }

      move(50, 2, BACKWARD);

			moveLift(40, 500, UP);

			move(50, 3, FORWARD);
		}
		else if (vcolumn == 3)
		{
			path2 (vside, 35, 13);
		}
	}
	else if (vpos == 3)
	{
		if (vcolumn == 1)
		{
			path1 (vside, 12, 14);
		}
		else if (vcolumn == 2)
		{
			move(50, 12, FORWARD);

			if (strcmp(vside, "left")== 0)
      {
        GyroTurn (50, 90, LEFT);
      }
    	else
      {
        GyroTurn (50, 90, RIGHT);
      }

			move(50, 13, FORWARD);

			if (strcmp(vside, "left")== 0)
      {
        GyroTurn (50, 90, RIGHT);
      }
    	else
      {
        GyroTurn (50, 90, LEFT);
      }

			move(50, 18, FORWARD);

			if (strcmp(vside, "left")== 0)
      {
        GyroTurn (50, 35, LEFT);
      }
    	else
      {
        GyroTurn (50, 35, RIGHT);
      }

			move(50, 1, BACKWARD);

			moveLift(40, 500, UP);

			move(50, 4, FORWARD);
		}
		else if (vcolumn == 3)
		{
			path3 (vside, 15);
		}
	}

	servo[pivotLeft] = 0;
	servo[pivotRight] = 255;

	if (vheight == 1)
	{
		moveLift(40, 571, DOWN);
	}
	else if (vheight == 2)
	{
		moveLift(40, 3095, DOWN);
	}
	else if (vheight == 3)
	{
		moveLift(40, 5233,DOWN);
	}

	/*if (vcolumn == 1)
	{
		move(50, 24, BACKWARD);
	}
	else if (vcolumn == 2)
	{
		move(50, 24, BACKWARD);

		if (strcmp(vside, "left")== 0)
    {
     	GyroTurn (50, 45, RIGHT);
    }
    else
    {
     	GyroTurn (50, 45, LEFT);
    }

    move(50, 18, BACKWARD);
  }
  else
  {
  	move(50, 13, BACKWARD);

  	if (strcmp(vside, "left")== 0)
    {
     	GyroTurn (50, 45, RIGHT);
    }
    else
   	{
   		GyroTurn (50, 45, LEFT);
   	}

   	move(50, 35, BACKWARD);
  }*/


/*if (vcolumn == 1)
	{
    GyroTurn (50, 145, LEFT);

		move(50, 6, FORWARD);

		servo[pivotLeft] = 127;
		servo[pivotRight] = 128;

		wait1Msec(500);

		moveLift(40, 250, UP);
	}
	else if (vcolumn == 2)
	{
	}
	else
	{
	}*/

	}

/////////////////////////////////////////////////////////////////////////////////////////////////
///                                       Defense
///
//////////////////////////////////////////////////////////////////////////////////////////////////

void defense (string vside)
  	{
  		int SensorVal1;
  		//int SensorVal2;
  		int BeaconPos;

    	if (strcmp(vside, "left") == 0)
    	{
    		servo [IR] = 20;
    	}
    	else
    	{
    		servo [IR] = 235;
    	}

    	move (100, 34, FORWARD);

    	if (strcmp(vside, "left") == 0)
    	{
    		GyroTurn (100, 30, RIGHT);
    	}

    	else
    	{
    		GyroTurn (100, 30, LEFT);
    	}

   		move (100, 14, FORWARD);

   		//First we must turn the robot until the beacon is in front of us
    	if (strcmp(gSide, "left")== 0)
    	{
  			while (SensorValue[irSeeker] < 7 && ServoValue[IR] < 255)
      	{
        	servo[IR] = ServoValue[IR] + 1;
      	}
			}
			else
			{
  			while (SensorValue[irSeeker] > 3 && ServoValue[IR] > 0)
      	{
        	servo[IR] = ServoValue[IR] - 1;
      	}
			}

    SensorVal1 = ServoValue[IR];

    BeaconPos = ServoValue[IR];

    //servo[IR] = 15;

    eraseDisplay();
    nxtDisplayCenteredTextLine(1, "Beacon Found");
    nxtDisplayTextLine(3, "%i",BeaconPos);

    //wait10Msec (10000);

    if (BeaconPos < 175)
    {
    	move(50, 0, FORWARD);
    }
    else if (BeaconPos > 176)
    {
    	move(50, 14, FORWARD);
    }

  }

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                       Counter Defense
// The following is the main code for the autonomous counter defensive operation.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
  void cdefense ()
  {
  	move (100, 13, FORWARD);
  }

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
task main()
  {
  	int vPath=1;
    initializeRobot();

    waitForStart(); // Wait for the beginning of autonomous phase.


    ///////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////
    ////                                                   ////
    ////    Add your robot specific autonomous code here.  ////
    ////                                                   ////
    ///////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////

    ////////////////////////////////
    // Debugging                  //
    ////////////////////////////////
    //moveforward (50,4000);
    //leftturn(50,v90turn);
    //GyroTurn(50,90,LEFT);
    //findBeacon(gPos, gSide);
    //driveBeacon();
    //servo[pivotLeft]  = 192;
    //servo[pivotRight] = 64;

    //wait1Msec (200);

    //servo[pivotLeft]  = 133;
    //servo[pivotRight] = 121;

    //moveLift(60,35,UP);
    //The following lines test the motor encoders for the drive wheels
    //First test the left motor

    /*nMotorEncoder[DriveLeft]  = 0;
    motor[DriveLeft]  = 60;
    while(abs(nMotorEncoder[DriveLeft]) < 2750)
      {
      	//do nothing until encoder meets target
      }
    motor[DriveLeft] = 0;
    //Next test the right motor
    nMotorEncoder[DriveRight]  = 0;
    motor[DriveRight]  = 60;
    while(abs(nMotorEncoder[DriveRight]) < 2750)
      {
      	//do nothing until encoder meets target
      }
    motor[DriveRight] = 0;*/
    //Finally test the lifter motor
    //nMotorEncoder[RightLifter1]  = 0;
    //motor[Lifter]  = 60;
    //while(abs(nMotorEncoder[Lifter]) < 2750)
     // {
      	//do nothing until encoder meets target
     // }
   // motor[Lifter] = 0;
    /*eraseDisplay();
while(true)
{
    nxtDisplayTextLine(3, "Value = %i",SensorValue[irSeeker]);
    nxtDisplayTextLine(5, "Pos   = %i",ServoValue[IR]);
}*/

    //////////////////////////////////
    //autonomous routines           //
    //////////////////////////////////

    if (gRun == "PlaceRing")
    {
      servo[pivotLeft] = 90;
   		servo[pivotRight] = 165;
      placering(gSide, gPos, gPath, gHeight);
    }
    else if (gRun == "Defense")
    {
      defense (gSide);
    }
    else if (gRun == "CDefense")
    {
      cdefense ();
    }
    else
    {
     	servo[pivotLeft] = 90;
    	servo[pivotRight] = 165;
      vPath = findBeacon(gPos, gSide);
     	placering(gSide, gPos, vPath, gHeight);
      //wait10Msec(1000);
    }
  }
