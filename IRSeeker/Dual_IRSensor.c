#pragma config(Sensor, S1,     leftIR,         sensorI2CCustom)
#pragma config(Sensor, S2,     rightIR,        sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/************************************************************
 * Dual IR Sensor code
 ************************************************************
 *
 * This program is a proof-of-concept to determine if two IR
 * sensors can be used to both sense direction and distance to
 * an IR beacon.
 *
 ************************************************************
 * Hardware Configuration
 * ----------------------
 * Sensors
 * -------
 * leftIR - Connected to Port 1 of the NXT brick
 * righttIR - Connected to Port 2 of the NXT brick
 *
 * Both sensors should be separated by the width
 ************************************************************
 */
#include "driver/HTIRS2-driver.h"

const int NUM_IR_SENSORS = 2;

// global variables
string sTextLines[8];

void initializeIRSensor(tSensors irSensor, const string sensorName, const string port) {
    // set the Seeker to 1200Hz
    int numTries = 0;
    while (!HTIRS2setDSPMode(irSensor, DSP_1200)) {
        numTries++;

        // Flash 'Initializing' text
        if ((numTries % 4) == 0)
            nxtDisplayTextLine(0, "Initializing...");
        else
            nxtDisplayTextLine(0, "");

        PlaySound(soundShortBlip);
        nxtDisplayCenteredTextLine(6, "Connect %s IR Sensor", sensorName);
        nxtDisplayCenteredTextLine(7, "to Port %s", port);
        wait1Msec(100);
    }
}

// Returns the direction as well as filling in the individual sensor values.
int readSensor(tSensors irSensor, int *sensorArr) {
    // Keep track of the previous direction to avoid spurious values completely
    // messing us up.
    static int prevDir[NUM_IR_SENSORS] = { 0, 0 };

    int sensorIndex;
    switch (irSensor) {
    case leftIR:
       sensorIndex = 0;
       break;

    case rightIR:
        sensorIndex = 0;
        break;
    }

    // Set the direction to the previous direction and zero
    // out the current readings until we read them in.
    int dir = prevDir[sensorIndex];
    for (int i = 0; i < 5; i++)
        sensorArr[i] = 0;

    // Read the direction first
    int newDir = HTIRS2readACDir(irSensor);
    if (newDir >= 0) {
        dir = newDir;
        // Read the individual values.
        HTIRS2readAllACStrength(irSensor, &sensorArr[0], &sensorArr[1], &sensorArr[2], &sensorArr[3], &sensorArr[4]);
    }
    prevDir[sensorIndex] = dir;
    return dir;
}

void initializeRobot() {
    initializeIRSensor(leftIR, "Left", "S1");
    initializeIRSensor(rightIR, "Right", "S2");
}

// Minimize LCD screen flicker by only updating LCD when data has changed
void displayText(int nLineNumber, const string cChar, int nValueDC, int nValueAC)
{
    string sTemp;

    StringFormat(sTemp, "%4d  %4d", nValueDC, nValueAC);
    // Check if the new line is the same as the previous one
    // Only update screen if it's different.
    if (sTemp != sTextLines[nLineNumber])
    {
        string sTemp2;

        sTextLines[nLineNumber] = sTemp;
        StringFormat(sTemp2, "%s:  %s", cChar, sTemp);
        nxtDisplayTextLine(nLineNumber, sTemp2);
    }
}

task main() {
    initializeRobot();

    // wait for start of tele-op phase
//    waitForStart();

    eraseDisplay();
    for (int i = 0; i < 8; ++i)
        sTextLines[i] = "";

    int dirLeftIR;
    int rawLeftIR[5];
    int dirRightIR;
    int rawRightIR[5];
    while (true) {
        // Read the left sensor values;
        dirLeftIR = readSensor(leftIR, rawLeftIR);
        dirRightIR = readSensor(rightIR, rawRightIR);

        displayText(1, "D", dirLeftIR, dirRightIR);
        displayText(2, "0", rawLeftIR[0], rawRightIR[0]);
        displayText(3, "1", rawLeftIR[1], rawRightIR[1]);
        displayText(4, "2", rawLeftIR[2], rawRightIR[2]);
        displayText(5, "3", rawLeftIR[3], rawRightIR[3]);
        displayText(6, "4", rawLeftIR[4], rawRightIR[4]);

        // Allow other routines a chance to do something
        EndTimeSlice();
    }
}
