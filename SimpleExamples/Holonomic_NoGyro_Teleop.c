#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,                    sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     frontLeft,     tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     frontRight,    tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     rearLeft,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     rearRight,     tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Include file to "handle" the Bluetooth messages.
#include "JoystickDriver.c"

// Forward declarations
void moveOmni();
int expoJoystick(int eJoy);

void initializeRobot()
{
    motor[frontLeft] = 0;
    motor[frontRight] = 0;
    motor[rearLeft] = 0;
    motor[rearRight] = 0;
}


task main()
{
    initializeRobot();

    // wait for start of tele-op phase
//    waitForStart();

    while (true) {
        // Get current joystick buttons and analog movements
        getJoystickSettings(joystick);

        // Move robot
        moveOmni();
    }
}

// Move the motor on the field
bool slowSpeedButtonWasPressed = false;
bool slowSpeedEnabled = false;
void moveOmni()
{
    // Make things less sensitive around the center (a slight
    // dead-band), and more aggressive at the extremes.
    int xJoy1 = expoJoystick(joystick.joy1_x1);
    int yJoy1 = expoJoystick(joystick.joy1_y1);
    int xJoy2 = expoJoystick(joystick.joy1_x2);

    // Calculte the power for each motor based on joystick settings
    int forward = yJoy1;
    int right = xJoy1;
    int rotCw = xJoy2;

    int flPow = forward + rotCw + right;
    int frPow = forward - rotCw - right;
    int rlPow = forward + rotCw - right;
    int rrPow = forward - rotCw + right;

    // Make sure none of the wheel power's exceed 100%.  If so, reduce
    // all by the same amount.
    int max = abs(flPow);
    if (abs(frPow) > max)
        max = abs(frPow);
    if (abs(rlPow) > max)
        max = abs(rlPow);
    if (abs(rrPow) > max)
        max = abs(rrPow);

    if (max > 100) {
        float reduction = 100.0 / (float)max;
        flPow *= reduction;
        frPow *= reduction;
        rlPow *= reduction;
        rrPow *= reduction;
    }

    // Check the low-speed power setting.  If set, reduce power by half.
    bool btnPress = joy1Btn(11);
    nxtDisplayString(2, "Btn=%d", btnPress);
    if (!btnPress && slowSpeedButtonWasPressed)
        slowSpeedEnabled = !slowSpeedEnabled;
    slowSpeedButtonWasPressed = btnPress;
    if (slowSpeedEnabled) {
        flPow /= 2;
        frPow /= 2;
        rlPow /= 2;
        rrPow /= 2;
    }
    motor[frontLeft] = flPow;
    motor[frontRight] = frPow;
    motor[rearLeft] = rlPow;
    motor[rearRight] = rrPow;
}

// http://www.chiefdelphi.com/forums/showthread.php?p=921992
const float SENSITIVITY = 0.7;
int expoJoystick(int eJoy)
{
    // convert the joystick inputs to a floating point number
    // between -1 and +1
    float floatJoy = (float)eJoy / 128.0;
    float result = SENSITIVITY * pow(floatJoy, 3) +
                   (1 - SENSITIVITY) * floatJoy;

    // Convert the number back to a joystick value
    return (int)(128.0 * result);
}
