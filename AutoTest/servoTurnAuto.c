#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     compass,        sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     light,          sensorLightActive)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    irServo,              tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//All angles given to a method are based on the unit circle
//All angles returned by a method are based on the unit circle

void moveRobot(float distance);
void rotateRobotTo(float angle);
float getAngleToBeacon();

const float moveDistance = 1;
const float distanceFromPeg = 1;
const float desiredX = distanceFromPeg * cosDegrees(45);
const float desiredY = distanceFromPeg * sinDegrees(45);

task main()
{
    //Move out so the robot has room to look for the IR Beacon
    moveRobot(moveDistance);

    //Get the first reference to the IR Beacon
    float firstAngle = getAngleToBeacon();
    nxtDisplayString(0, "%f", firstAngle);

    //Move again, to make the angle change
    moveRobot(moveDistance);

    //Get the second reference to the IR Beacon
    float secondAngle = getAngleToBeacon();
    nxtDisplayString(1, "%f", secondAngle);
    //Beacon is initially on the right
    if (firstAngle < 180 && firstAngle > 90) { //Beacon is initialliy on the left
        //The second angle should always be larger than the first, if the two angles converge
        float thirdAngle = secondAngle - firstAngle;

        float r = (moveDistance * sinDegrees(180 - firstAngle)) / (sinDegrees(thirdAngle));
        float right = -cosDegrees(secondAngle) * r; // how far right of the ir beacon
        float down = sinDegrees(secondAngle) * r; // how far 'below' the ir beacon
        float leftMov = right - desiredX;
        float upMov = down - desiredY;
        float movDist = pow(leftMov, 2) + pow(upMov, 2);
        movDist = pow(movDist, 0.5);
        nxtDisplayString(2, "%f", movDist);
        nxtDisplayString(3, "(%f, %f)", right, down);
        float movAngle = radiansToDegrees(atan2(upMov, -leftMov));
        nxtDisplayString(4, "%f", movAngle);
        rotateRobotTo(movAngle);
        moveRobot(movDist);
        rotateRobotTo(135);
    }else if(firstAngle > 0 && firstAngle < 90){

	}
}

const int FORWARD_POWER = 35;
const int MOVE_FOOT_TIME = 2000;
void moveRobot(float distance) {
    if (distance == 0)
        return;

    // We need to wait now + the amount of time to move one foot
    int endTime = nPgmTime + abs(distance) * MOVE_FOOT_TIME;

    // Turn on the motors and wait for the appropriate amount of time for the movement to occur
    if (distance > 0) {
        motor[motorD] = FORWARD_POWER;
        motor[motorE] = FORWARD_POWER;
    } else {
        motor[motorD] = -FORWARD_POWER;
        motor[motorE] = -FORWARD_POWER;
    }
    while (nPgmTime < endTime)
        EndTimeSlice();

    motor[motorD] = 0;
    motor[motorE] = 0;
}

const int TURN_POWER = 30;
const int COMPLETE_REVOLUTION_TIME = 10000;
int curAngle = 90;
void rotateRobotTo(float angle) {
    float relativeAngle = curAngle-angle;
    if (angle == 0)
        return;

    // How long it should take
    int endTime = nPgmTime + (abs(relativeAngle) / 360.0) * COMPLETE_REVOLUTION_TIME;

    // Turn on the motors and wait for the appropriate amount of time for the movement to occur
    if (relativeAngle < 0) { //Turn right
        motor[motorD] = TURN_POWER;
        motor[motorE] = -TURN_POWER;
    } else { //Turn left
        motor[motorD] = -TURN_POWER;
        motor[motorE] = TURN_POWER;
    }
    while (nPgmTime < endTime)
        EndTimeSlice();
    curAngle = angle;
    motor[motorD] = 0;
    motor[motorE] = 0;
}

float getAngleToBeacon()
{
	int startingSection = SensorValue[S2];
	int lastSection = SensorValue[S2];
	float res = 90.0;
	bool running = true;
	if(startingSection < 5){
		int resPos = 0;
		while(running){
			servo[irServo] = ServoValue[irServo]+1;
			wait1Msec(muxUpdateInterval);
			if(SensorValue[S2] == 5 && lastSection == 4){
				resPos = ServoValue[irServo];
				running = false;
			}
		}
		res = 180.0/256.0 * resPos - 15.0;
	}else if(startingSection > 5){
		int resPos = 0;
		while(running){
			servo[irServo] = ServoValue[irServo]-1;
			wait1Msec(muxUpdateInterval);
			if(SensorValue[S2] == 5 && lastSection == 6){
				resPos = ServoValue[irServo];
				running = false;
			}
		}
		res = 180.0/256.0 * resPos + 15.0;
	}else{
		int resPos = 0;
		while(running){
			servo[irServo] = ServoValue[irServo]+1;
			wait1Msec(muxUpdateInterval);
			if(SensorValue[S2] == 6){
				resPos = ServoValue[irServo];
				running = false;
			}
		}
		res = 180.0/256.0 * resPos - 15.0;
	}
	servo[irServo] = 128;
	return res;
}
