#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     compass,        sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     light,          sensorLightActive)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//All angles given to a method are based on the unit circle
//All angles returned by a method are based on the unit circle

void moveRobot(float distance);
void rotateRobotTo(float angle);
float getAngleToBeacon();

const float moveDistance = 1;
const float distanceFromPeg = 1;
const float desiredX = distanceFromPeg * cosDegrees(45);
const float desiredY = distanceFromPeg * sinDegrees(45);

task main()
{
	if(SensorValue[S2] == 5){ //must be far right
		moveRobot(1.0);
		rotateRobotTo(0);
		moveRobot(0.5);
		rotateRobotTo(90);
		moveRobot(3.92);
		rotateRobotTo(135);
		moveRobot(0.6);
	}else if(SensorValue[S2] == 4){
		moveRobot(1.08);//Now we need to differentiate
		if(SensorValue[S2] == 3) { // must be far left
			rotateRobotTo(135);
			moveRobot(2.95);
		}else if(SensorValue[S2] == 4) { //then it is the center
			rotateRobotTo(0);
			moveRobot(0.5);
			rotateRobotTo(90);
			moveRobot(1.92);
			rotateRobotTo(135);
			moveRobot(1.75);
		}
	}
}

const int FORWARD_POWER = 35;
const int MOVE_FOOT_TIME = 2000;
void moveRobot(float distance) {
    if (distance == 0)
        return;

    // We need to wait now + the amount of time to move one foot
    int endTime = nPgmTime + abs(distance) * MOVE_FOOT_TIME;

    // Turn on the motors and wait for the appropriate amount of time for the movement to occur
    if (distance > 0) {
        motor[motorD] = FORWARD_POWER;
        motor[motorE] = FORWARD_POWER;
    } else {
        motor[motorD] = -FORWARD_POWER;
        motor[motorE] = -FORWARD_POWER;
    }
    while (nPgmTime < endTime)
        EndTimeSlice();

    motor[motorD] = 0;
    motor[motorE] = 0;
}

const int TURN_POWER = 30;
const int COMPLETE_REVOLUTION_TIME = 10000;
int curAngle = 90;
void rotateRobotTo(float angle) {
	float relativeAngle = curAngle-angle;
	nxtDisplayString(0,"%f",relativeAngle);
    if (relativeAngle == 0)
        return;

    // How long it should take
    int endTime = nPgmTime + (abs(relativeAngle) / 360.0) * COMPLETE_REVOLUTION_TIME;
	nxtDisplayString(1,"%i",endTime);
    // Turn on the motors and wait for the appropriate amount of time for the movement to occur
    if (relativeAngle < 0) { //Turn right
        motor[motorD] = TURN_POWER;
        motor[motorE] = -TURN_POWER;
    } else { //Turn left
        motor[motorD] = -TURN_POWER;
        motor[motorE] = TURN_POWER;
    }
    while (nPgmTime < endTime)
        EndTimeSlice();
	curAngle = angle;
    motor[motorD] = 0;
    motor[motorE] = 0;
}