#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     compass,        sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     light,          sensorLightActive)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//All angles given to a method are based on the unit circle
//All angles returned by a method are based on the unit circle

void moveRobot(float distance);
void rotateRobotTo(float angle);
float getAngleToBeacon();

const float moveDistance = 1;
const float distanceFromPeg = 1;
const float desiredX = distanceFromPeg * cosDegrees(45);
const float desiredY = distanceFromPeg * sinDegrees(45);

task main()
{
	//Move out so the robot has room to look for the IR Beacon
    moveRobot(moveDistance);

    //Get the first reference to the IR Beacon
    float firstAngle = getAngleToBeacon();
	nxtDisplayString(0, "%f", firstAngle);
    //Move again, to make the angle change
    moveRobot(moveDistance);

    //Get the second reference to the IR Beacon
    float secondAngle = getAngleToBeacon();
	//Beacon is initially on the right
	if (firstAngle < 180 && firstAngle > 90) { //Beacon is initialliy on the left
    	//The second angle should always be larger than the first, if the two angles converge
        float thirdAngle = secondAngle - firstAngle;

        float r = (moveDistance * sinDegrees(180 - firstAngle)) / (sinDegrees(thirdAngle));
        float right = -cosDegrees(secondAngle) * r; // how far right of the ir beacon
        float down = sinDegrees(secondAngle) * r; // how far 'below' the ir beacon
        float leftMov = right - desiredX;
        float upMov = down - desiredY;
        float movDist = pow(leftMov, 2) + pow(upMov, 2);
        movDist = pow(movDist, 0.5);
        nxtDisplayString(2, "%f", movDist);
        nxtDisplayString(1, "(%f, %f)", right, down);
        float movAngle = degreesToRadians(atan2(upMov, -leftMov));
        nxtDisplayString(0, "%f", movAngle);
        rotateRobotTo(movAngle);
        moveRobot(movDist);
        rotateRobotTo(135);
    }
}

const int FORWARD_POWER = 35;
const int MOVE_FOOT_TIME = 2000;
void moveRobot(float distance) {
    if (distance == 0)
        return;

    // We need to wait now + the amount of time to move one foot
    int endTime = nPgmTime + abs(distance) * MOVE_FOOT_TIME;

    // Turn on the motors and wait for the appropriate amount of time for the movement to occur
    if (distance > 0) {
        motor[motorD] = FORWARD_POWER;
        motor[motorE] = FORWARD_POWER;
    } else {
        motor[motorD] = -FORWARD_POWER;
        motor[motorE] = -FORWARD_POWER;
    }
    while (nPgmTime < endTime)
        EndTimeSlice();

    motor[motorD] = 0;
    motor[motorE] = 0;
}

const int TURN_POWER = 30;
const int COMPLETE_REVOLUTION_TIME = 10000;
int curAngle = 90;
void rotateRobotTo(float angle) {
	float relativeAngle = curAngle-angle;
    if (angle == 0)
        return;

    // How long it should take
    int endTime = nPgmTime + (abs(relativeAngle) / 360.0) * COMPLETE_REVOLUTION_TIME;

    // Turn on the motors and wait for the appropriate amount of time for the movement to occur
    if (relativeAngle < 0) { //Turn right
        motor[motorD] = TURN_POWER;
        motor[motorE] = -TURN_POWER;
    } else { //Turn left
        motor[motorD] = -TURN_POWER;
        motor[motorE] = TURN_POWER;
    }
    while (nPgmTime < endTime)
        EndTimeSlice();
	curAngle = angle;
    motor[motorD] = 0;
    motor[motorE] = 0;
}

float getAngleToBeacon()
{
    // Sweep left 90 degrees
    int startTime = nPgmTime;
    motor[motorD] = TURN_POWER;
    motor[motorE] = -TURN_POWER;

    // Wait for an IR sensor hit
    int prevIrSection = SensorValue[S2];
    int leftAngle = 0;
    while (leftAngle == 0) {
        // Sweeping left, we calculate the angle the first time we read
        // the transition from section 5->6 on the IR sensor
        int irSection = SensorValue[S2];
        if (leftAngle == 0 && prevIrSection == 5 && irSection == 6) {
            // Approximate based on time
            float sweepTime = nPgmTime - startTime;
            leftAngle = -sweepTime / COMPLETE_REVOLUTION_TIME * 360.0;
        }
        prevIrSection = irSection;
        EndTimeSlice();
    }
    int lTime = nPgmTime - startTime;
    float lRot = (float)lTime / COMPLETE_REVOLUTION_TIME * 360.0;
    // Sweep the other way
    startTime = nPgmTime;
    motor[motorD] = -TURN_POWER;
    motor[motorE] = TURN_POWER;
    int rightAngle = 0;
    while (rightAngle == 0) {
        // Sweeping right, we calculate the angle the first time we read
        // the transaction from section 5 -> 4 on the IR sensor
        int irSection = SensorValue[S2];
        if (rightAngle == 0 && prevIrSection == 5 && irSection == 4) {
            // Approximate based on time
            float sweepTime = nPgmTime - startTime;
            rightAngle = sweepTime / COMPLETE_REVOLUTION_TIME * 360.0 - lRot;
        }
        prevIrSection = irSection;
        EndTimeSlice();
    }
    int rTime = nPgmTime - startTime;
    // Return back to starting position
    startTime = nPgmTime;
    if (rTime > lTime) {
        motor[motorD] = TURN_POWER;
        motor[motorE] = -TURN_POWER;
        while (startTime + (lTime - rTime) > nPgmTime)
            EndTimeSlice();
    } else {
        motor[motorD] = -TURN_POWER;
        motor[motorE] = TURN_POWER;
        while (startTime + (lTime - rTime) > nPgmTime)
            EndTimeSlice();
    }

    // Done, turn off the motors
    motor[motorD] = 0;
    motor[motorE] = 0;

    // Average angle is the addition of the left and right angles
    float res =  (leftAngle + rightAngle) / 2;
    return -res+90; //Format to unit circle
}
