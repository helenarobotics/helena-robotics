#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     compass,        sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     light,          sensorLightActive)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float MOVE_DIST = 1.0;

void moveRobot(float distance);
void rotateRobot(float angle);
float findIRBeacon(int numSweeps);
void putRing();

// Time-based distances (WAGs based on VirtualWorld behavior)
const int FORWARD_POWER = 35;
const int MOVE_FOOT_TIME = 1000;
const int TURN_POWER = 30;
const int COMPLETE_REVOLUTION_TIME = 10000;

void initializeRobot() {
    motor[motorD] = 0;
    motor[motorE] = 0;
}

task main()
{
    // Turn everything off
    initializeRobot();

    // Drive forward to get away from the wall.
    moveRobot(MOVE_DIST);

    //Find the IR Beacon
    float firstAngle = findIRBeacon(1);

    // Delay so we can see the correction on the screen
    wait10Msec(100);

    // Point robot at beacon
    rotateRobot(firstAngle);
/*
    //MOVE ROBOT FW 2 FT
    moveRobot(MOVE_DIST);
    float secondAngle = findIRBeacon(2);

    if (firstAngle < 90) {
        //Create a vector of secondAngle and r
        float r = (MOVE_DIST * sin(firstAngle)) / (sin(firstAngle - secondAngle));
        //Find how far to the right and how far up you have to move
        //NOTE: may want to use cosDegrees if using degrees
        float right = cos(secondAngle) * r;
        float up = sin(secondAngle) * r;
        if (right > up) {
            //Move right right-up
            moveRobot(right - up, 0);
        } else if (right < up) {
            //Move down up-right
            moveRobot(0, up - right);
        }
        //Rotate 45 degrees ccw
        rotateRobot(-45);

        //Move robot forward to an amount before the post
        moveRobot(0, sqrt(2) * up - PEG_DIST);
        putRing();
    } else if (firstAngle == 90) {
        //Somehow, the robot is already facing the beacon
        //I have no idea how far to move
        //This SHOULD not happen
    } else {
        //Create a vector of secondAngle and r
        float r = (MOVE_DIST * sin(firstAngle)) / (sin(secondAngle - firstAngle));
        //Find how far to the right and how far up you have to move
        //NOTE: may want to use cosDegrees if using degrees
        float left = -cos(secondAngle) * r;
        float up = sin(secondAngle) * r;

        //Move to be at a 45 degree angle to the peg - it may be better
        //to move away from the peg to line up, in case you get too close
        if (left > up) {
            //Move left left-up
            moveRobot(up - left, 0);
        } else if (left < up) {
            //move up up-left
            moveRobot(0, up - left);
        }

        //Rotate 45 degrees cw
        rotateRobot(45);

        //Move robot forward to an amount before the post
        moveRobot(0, sqrt(2) * up - PEG_DIST);
        putRing();
    }
*/
}

float findIRBeacon(int numSweeps)
{
    int totalAngleValue = 0;

    // Start sweeping
    for (int i = 0; i < numSweeps; i++) {
        // Sweep left 90 degrees
        int startTime = nPgmTime;
        int totalSweepTime = COMPLETE_REVOLUTION_TIME * 90 / 360;
        motor[motorD] = TURN_POWER;
        motor[motorE] = -TURN_POWER;

        // Wait for an IR sensor hit
        int prevIrSection = SensorValue[S2];
        int leftAngle = 0;
        while (startTime + totalSweepTime > nPgmTime) {
            // Sweeping left, we calculate the angle the first time we read
            // the transition from section 5->6 on the IR sensor
            int irSection = SensorValue[S2];
            if (leftAngle == 0 && prevIrSection == 5 && irSection == 6) {
                // Approximate based on time
                float sweepTime = nPgmTime - startTime;
                leftAngle -= 90 * (sweepTime / totalSweepTime);
            }
            prevIrSection = irSection;
            EndTimeSlice();
        }

        // Sweep the other way
        startTime = nPgmTime;
        totalSweepTime = COMPLETE_REVOLUTION_TIME * 180 / 360;
        motor[motorD] = -TURN_POWER;
        motor[motorE] = TURN_POWER;
        int rightAngle = 0;
        while (startTime + totalSweepTime > nPgmTime) {
            // Sweeping right, we calculate the angle the first time we read
            // the transaction from section 5 -> 4 on the IR sensor
            int irSection = SensorValue[S2];
            if (rightAngle == 0 && prevIrSection == 5 && irSection == 4) {
                // Approximate based on time
                float sweepTime = nPgmTime - startTime;
                rightAngle = 180 * (sweepTime / totalSweepTime) - 90;
            }
            prevIrSection = irSection;
            EndTimeSlice();
        }

        // Return back to starting position
        startTime = nPgmTime;
        totalSweepTime = COMPLETE_REVOLUTION_TIME * 90 / 360;
        motor[motorD] = TURN_POWER;
        motor[motorE] = -TURN_POWER;
        while (startTime + totalSweepTime > nPgmTime)
            EndTimeSlice();

        // Done, turn off the motors
        motor[motorD] = 0;
        motor[motorE] = 0;

        // Average angle is the addition of the left and right angles
        totalAngleValue += (leftAngle + rightAngle) / 2;
    }

    // Return angle relative to the robot
    float averageAngle = totalAngleValue / numSweeps;
    return averageAngle;
}

//Move robot, but retain direction
void moveRobot(float distance) {
    if (distance == 0)
        return;

    // We need to wait now() + the amount of time to move one foot
    int endTime = nPgmTime + abs(distance) * MOVE_FOOT_TIME;
    endTime = nPgmTime + 2000;

    // Turn on the motors and wait for the appropriate amount of time for the movement to occur
    if (distance > 0) {
        motor[motorD] = FORWARD_POWER;
        motor[motorE] = FORWARD_POWER;
    } else {
        motor[motorD] = -FORWARD_POWER;
        motor[motorE] = -FORWARD_POWER;
    }
    while (nPgmTime < endTime)
        EndTimeSlice();

    motor[motorD] = 0;
    motor[motorE] = 0;
}

//Rotate robot, but retain position
void rotateRobot(float angle) {
    if (angle == 0)
        return;

    // How long it should take
    int endTime = nPgmTime + (abs(angle) / 360) * COMPLETE_REVOLUTION_TIME;

    // Turn on the motors and wait for the appropriate amount of time for the movement to occur
    if (angle > 0) {
        motor[motorD] = -TURN_POWER;
        motor[motorE] = TURN_POWER;
    } else {
        motor[motorD] = TURN_POWER;
        motor[motorE] = -TURN_POWER;
    }
    while (nPgmTime < endTime)
        EndTimeSlice();

    motor[motorD] = 0;
    motor[motorE] = 0;
}

//Put ring on peg
void putRing() {

}
