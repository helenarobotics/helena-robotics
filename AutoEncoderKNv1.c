#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Motor,  motorA,          mDispWristL,   tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorB,          mDispWristR,   tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     mLTrack,       tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     mRTrack,       tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     mBatonArm,     tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     mBridgeArm,    tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     mDispArm,      tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     mRGLiftArm,    tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    ,                     tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    sBatonCup,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    sRGTeethL,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_5,    sRGTeethR,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    sDispCup,             tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This is necessary so that waitForStart() communication from the
// Samantha Field Control is received properly.  Otherwise,
// waitForStart() is undefined.
#include "JoystickDriver.c"

// Shared code that both Auto and Teleop use
#include "SharedKNv1.c"

/**************************************************
 * Code for Autonomous Mode
 * By Bridger Howell
 * Team 4309
 **************************************************
 * Motors
 * ------
 * mLTrack
 *      Controls tank track movement (left track)
 * mRTrack
 *      Controls tank track movement (right track)
 * mBatonArm
 *      Controls the baton/blocking arm with the attached baton cup (right arm)
 * mBridgeArm
 *      Controls bridge lowering arm (left arm)
 **************************************************
 * Servos
 * ------
 * sBatonCup
 *      Controls the baton cup on baton arm (mBatonArm)
 **************************************************
 */

// Encoder clicks for movement
const int FOOT_TIME_TICKS = 2200;
const int FULL_TURN_TICKS = 8000;

// How often do we check the encoders to make sure we are mostly in
// sync.
const long SYNC_CHECK_TIME = 250;

// Power constants
const int STRAIGHT_POWER = 100;
const int TURN_POWER = 50;

// Move the robot
typedef enum {
    STRAIGHT,
    TURN,
} cmdState;

void move(cmdState cmd, float amt);
void moveWait(cmdState cmd, float amt);

// Usability functions
bool stillMoving();
int calcMove(float dist);
int calcTurn(float deg);
task MoveTask();

void initializeRobot()
{
    // The tracks are controlled via the joystick and have no background
    // tasks, so turn off the motors and initialize their encoders.
    motor[mLTrack] = 0;
    motor[mRTrack] = 0;
    nMotorEncoder[mLTrack] = 0;
    nMotorEncoder[mRTrack] = 0;

    // Startup the routines that control the different robot
    // attachments (arms, servos, etc..)
    StartTask(BatonArmTask);
    StartTask(BatonCupTask);
    StartTask(BridgeArmTask);
    StartTask(MoveTask);
}

// Autonomous code start
task main()
{
    // Setup the robot to be where we want it to be.
    initializeRobot();

    // Start when the teleop phase begins.
    waitForStart();

    // Do the autonomous thing
    moveWait(STRAIGHT, 2.5);

    // Move forward up to the rolling goal
    deployBatonArmWait();

    // Turn 'left' to capture the goal
    moveWait(TURN, -45.0);

    // Knock the bridge down
    deployBridgeArmWait();

    // Deploy the batons and wait for them to drop
    openBatonCup();
    wait1Msec(500);

    // Move across the bridge far enough so the rolling goal falls to
    // the other side.
    moveWait(STRAIGHT, 3.0);

    // Start the cleanup routines
    closeBatonCup();
    parkBatonArm();
    parkBridgeArm();

    // Backup to the center of the bridge.
    moveWait(STRAIGHT, -1.5);

    // Hopefully we're balanced on the bridge now
}

typedef enum {
    STOP,
    FORWARD,
    MOVING,
    BACKWARD,
    TURN_LEFT,
    TURN_RIGHT,
} motorState;

motorState mState = STOP;
int motorPower;
int motorTicks;

bool stillMoving()
{
    // This makes sure that we can read the other thread's update to
    // mState.
    hogCPU();
    bool result = (mState != STOP);
    releaseCPU();
    return result;
}

void move(cmdState cmd, float amt)
{
    // Nothing to do!
    if (amt == 0.0)
        return;

    // Make sure we can safely move!
    if (stillMoving()) {
        nxtDisplayString(1, "%d", "Motor still moving");
        return;
    }

    motorState nState;
    switch (cmd) {
    case STRAIGHT:
        motorPower = STRAIGHT_POWER;
        motorTicks = calcMove(abs(amt));
        if (amt > 0)
            nState = FORWARD;
        else
            nState = BACKWARD;
        break;

    case TURN:
        // Normalize the output to -180 <- +180
        while (amt < -180)
            amt += 360;
        while (amt > 180)
            amt -= 360;
        motorPower = TURN_POWER;
        motorTicks = calcTurn(abs(amt));
        if (amt > 0)
            nState = TURN_RIGHT;
        else
            nState = TURN_LEFT;
        break;
    }
    // Safely update the state!
    hogCPU();
    mState = nState;
    releaseCPU();
}

void moveWait(cmdState cmd, float amt)
{
    move(cmd, amt);
    while (stillMoving())
        EndTimeSlice();
}

int lTargetPow, rTargetPow;
int lCurrPow, rCurrPow;

task MoveTask()
{
    long nxtSyncTime = nPgmTime() + SYNC_CHECK_TIME;

    while (true) {
        int lPos = nMotorEncoder[mLTrack];
        int rPos = nMotorEncoder[mRTrack];
        nxtDisplayString(4, "L/R %d/%d", lPos, rPos);
        switch (mState) {
        case STOP:
            // Shutoff the motors
            rPow = 0;
            lPow = 0;
            break;

        case FORWARD:
            // Both motors go forward
            nMotorEncoder[mLTrack] = 0;
            nMotorEncoder[mRTrack] = 0;
            lTargetPow = motorPower;
            rTargetPow = motorPower;
            lPow = motorPower;
            rPow = motorPower;
            nxtSyncTime = nPgmTime() + SYNC_CHECK_TIME;
            mState = MOVING;
            break;

        case BACKWARD:
            // Both motors go backward
            nMotorEncoder[mLTrack] = 0;
            nMotorEncoder[mRTrack] = 0;
            lTargetPow = lPow = -motorPower;
            rTargetPow = rPow = -motorPower;
            nxtSyncTime = nPgmTime() + SYNC_CHECK_TIME;
            mState = MOVING;
            break;

        case TURN_LEFT:
            // Motors reversed
            nMotorEncoder[mLTrack] = 0;
            nMotorEncoder[mRTrack] = 0;
            lTargetPow = lPow = -motorPower;
            rTargetPow = rPow = motorPower;
            nxtSyncTime = nPgmTime() + SYNC_CHECK_TIME;
            mState = MOVING;
            break;

        case TURN_RIGHT:
            // Motors reversed
            nMotorEncoder[mLTrack] = 0;
            nMotorEncoder[mRTrack] = 0;
            lTargetPow = lPow = motorPower;
            rTargetPow = rPow = -motorPower;
            nxtSyncTime = nPgmTime() + SYNC_CHECK_TIME;
            mState = MOVING;
            break;

        case MOVING:
            // Shutdown each motor individually to try and make sure we
            // keep the tracks 'sort of' in sync.
            if (lPos >= motorTicks)
                lPow = 0;
            if (rPos >= motorTicks)
                rPow = 0;

            if (lPos >= motorTicks && rPos >= motorTicks) {
                // This makes sure that we safely set the mState so that
                // other threads can read it.
                hogCPU();
                mState = STOP;
                releaseCPU();
            } else if (nPgmTime() >= nxtSynctime) {
                // We default to slowing down the motors if we have no
                // other choice.  The only time we speed up motors is if
                // they have been previously slowed.
                if (rPos < lPos) {
                    if (rPow < rTargetPow) {
                        rPow++;
                    } else {
                        lPow--;
                    }
                } else if (lPow < rPos) {
                    if (lPow < lTargetPow) {
                        lPow++;
                    } else {
                        rPow--;
                    }
                }

                // Wait a bit before checking the encoder positions.
                nxtSyncTime = nPgmTime() + SYNC_CHECK_TIME;
            }
            break;
        }
        motor[mLTrack] = lPow;
        motor[mRTrack] = rPow;
    }
}

int calcMove(float dist)
{
    return (int)(dist * (float)FOOT_TIME_TICKS);
}

int calcTurn(float deg)
{
    // How much of a a full turn are we doing here?
    return (int)((float)FULL_TURN_TICKS * deg / 360.0);
}
