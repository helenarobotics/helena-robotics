#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,          gripMotor,     tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          wristMotor,    tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     rightMotor,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     leftMotor,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     armMotor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/************************************************************
 *
 * Virtual Worlds Gripper Robot robot in Arcade mode
 *
 ************************************************************
 *
 * This program is setup to move the robot using the joystick following
 * arcade drive controls.
 *
 ************************************************************
 * Controls:
 * ---------
 *
 * Joystick 1:
 *   Left Analog - Y-Axis
 *      Controls the forward/backward direction of the robot
 *   Right Analog - X-Axis
 *      Controls the left/right rotation of the robot
 *
 *   Button 11
 *      Toggles slow-speed drive mode. When enabled, the robot moves at
 *      half-speed.
 *
 *   Left-back buttons (buttons 5 / 7)
 *      Move the arm up/down
 *
 *   Right top buttons X/B (buttons 1 / 3)
 *      Gripper controls
 *
 ************************************************************
 * Hardware Configuration
 * ----------------------
 * GripperBot for Virtual Worlds
 *
 * Joystick
 * --------
 * A single Logitech USB joystick must be connected to the computer and
 * verified to be working.
 ************************************************************
 */

//Include file to "handle" the joystick messages from Bluetooth and/or
//the Samantha module.
#include "JoystickDriver.c"

// Forward declarations
void moveArcade();
void moveArm();
void moveGripper();

int expoJoystick(int eJoy);
#define MAX(n1, n2)        (((n1) <= (n2)) ? (n1) : (n2))

void initializeRobot() {
    motor[leftMotor] = 0;
    motor[rightMotor] = 0;

    motor[armMotor] = 0;
}

task main() {
    initializeRobot();

    while (true) {
        // Get current joystick buttons and analog movements
        getJoystickSettings(joystick);

        // Move robot
        moveArcade();

        // Move arm
        moveArm();

        // Move gripper
        moveGripper();
    }
}

// Move the motor on the field
bool slowSpeedButtonWasPressed = false;
bool slowSpeedEnabled = false;
void moveArcade()
{
    // Expo makes things less sensitive around the center (a slight
    // dead-band), and more aggressive at the extremes.
    int straightPower = expoJoystick(joystick.joy1_y1);
    int turnPower = expoJoystick(joystick.joy1_x2);

    // Combine the two for each motor
    int leftPow = straightPower + turnPower;
    int rightPow = straightPower - turnPower;

    // Ensure that we don't try to give too much power to the motor.
    float maxPow = MAX(leftPow, rightPow);
    if (maxPow > 100) {
        float reduction = 100.0 / maxPow;
        leftPow *= reduction;
        rightPow *= reduction;
    }

    // Check the low-speed power setting.  If set, reduce power by half.
    bool btnPress = joy1Btn(11);
    nxtDisplayString(2, "Btn=%d", btnPress);
    if (!btnPress && slowSpeedButtonWasPressed)
        slowSpeedEnabled = !slowSpeedEnabled;
    slowSpeedButtonWasPressed = btnPress;
    if (slowSpeedEnabled) {
        leftPow /= 2;
        rightPow /= 2;
    }

    motor[leftMotor] = leftPow;
    motor[rightMotor] = rightPow;
}

// Raise/lower the arm
void moveArm()
{
    if (joy1Btn(5))
        motor[armMotor] = 40;
    else if (joy1Btn(7))
        motor[armMotor] = -30;
    else
        motor[armMotor] = 0;
}

// open/close the gripper
void moveGripper()
{
    if (joy1Btn(3))
        motor[gripMotor] = 40;
    else if (joy1Btn(1))
        motor[gripMotor] = -40;
    else
        motor[gripMotor] = 0;
}

// http://www.chiefdelphi.com/forums/showthread.php?p=921992
const float SENSITIVITY = 0.7;
int expoJoystick(int eJoy)
{
    // convert the joystick inputs to a floating point number
    // between -1 and +1
    float floatJoy = (float)eJoy / 128.0;
    float result = SENSITIVITY * pow(floatJoy, 3) +
                   (1 - SENSITIVITY) * floatJoy;

    // Convert the number back to a motor power, which is between -100
    // and 100.
    return (int)(100.0 * result);
}
