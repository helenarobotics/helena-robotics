#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,                    sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C2_1,     leftMotor,     tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     rightMotor,    tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     leftLifterMotor, tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     rightLifterMotor, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     ballMotor,     tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     basketTurnMotor, tmotorNormal, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_2,    leftGripperServo,     tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    rightGripperServo,    tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
int leftGripperPosition;
int rightGripperPosition;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void initializeRobot()
{
  servo[leftGripperServo] = 120;
  servo[rightGripperServo] = 90;
  leftGripperPosition=90;
  rightGripperPosition=90;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                               adjJoystickMotorPower
//
// As the range of values for the joysticks are -128 to 127 and the range of power settings for the
// motors are -100 to 100. We must adjust the joystick values to be within the motor values. This
// will allow the best driving experience for the robot.
//
// Also, since the joysticks do not always center exactly at position 0 when released, we use a
// thresh hold value to provide a small range of values that all equate to no movement
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
int adjJoystickMotorPower(int i_joystickReading, int i_rangeMax, int i_threshHold)
{
  int vMotorPower = i_joystickReading;

  //Compare to the thresh hold to account for variations in calibration
  if (abs(vMotorPower) < i_threshHold)
  {
    vMotorPower = 0;
  }
  else
  {
    //The value is outside the thresh hold. We now need to adjust to the
    //desired range. To do this first we need to subtract our thresh hold value
    vMotorPower = vMotorPower - i_threshHold;

    //Next we adjust for our range
    vMotorPower = floor((vMotorPower * i_rangeMax) / (127 - i_threshHold));
  }

  return vMotorPower;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      MotorControl
//
// This procedure is responsible for translating the joystick readings into motor power for all
// the various motors on the robot
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void movementControl()
{
  int leftMotorPower;
  int rightMotorPower;
  int maxMotorPower;

  if (joy1Btn(5))
  {
    maxMotorPower = 100;
  }else if (joy1Btn(7))
  {
    maxMotorPower = 20;
  }else
  {
    maxMotorPower = 60;
  }
    leftMotorPower = adjJoystickMotorPower(joystick.joy1_y1, maxMotorPower, 5);
    rightMotorPower = adjJoystickMotorPower(joystick.joy1_y2, maxMotorPower, 5);

    motor[rightMotor] = rightMotorPower;
    //motor[rightBackMotor] = rightMotorPower;
    motor[leftMotor] = leftMotorPower;
    //motor[leftBackMotor] = leftMotorPower;
  //}
}

void ballControl()
{
  if (joy1Btn(6))
  {
    motor[ballMotor]=100;
  }
  else if (joy1Btn(8))
  {
    motor[ballMotor]=-100;
  }
  else
  {
    motor[ballMotor]=0;
  }
}


void lifterControl()
{
  int lifterPower;
  int lifterMaxPower;

 /* if (joy2Btn(5))
  {
    elevatorMaxPower = 75;
  }else if (joy2Btn(7))
  {
    elevatorMaxPower = 25;
  }else
  {
    elevatorMaxPower = 50;
  }*/
lifterMaxPower=100;

  lifterPower = adjJoystickMotorPower(joystick.joy2_y1, lifterMaxPower, 5);

  motor[leftLifterMotor] = lifterPower;
  motor[rightLifterMotor]=lifterPower;
}

void GripperControl()
{
if (joy2Btn(5))
{
  leftGripperPosition=ServoValue[leftGripperServo];
  servo[leftGripperServo]=leftGripperPosition+2;
}
else if (joy2Btn(7))
{
  leftGripperPosition=ServoValue[leftGripperServo];
  servo[leftGripperServo]=leftGripperPosition-2;
}
else
{
  servo[leftGripperServo]=leftGripperPosition;
}


if (joy2Btn(8))
{
  rightGripperPosition=ServoValue[rightGripperServo];
  servo[rightGripperServo]=rightGripperPosition+2;
}
else if (joy2Btn(6))
{
  rightGripperPosition=ServoValue[rightGripperServo];
  servo[rightGripperServo]=rightGripperPosition-2;
}
else
{
  servo[rightGripperServo]=rightGripperPosition;
}
}

void basketControl()
{
if (joy2Btn(1))
{
  motor[basketTurnMotor]=15;
}
else if (joy2Btn(2))
{
  motor[basketTurnMotor]=-15;
}
else
{
  motor[basketTurnMotor]=0;
}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the tele-op robot operation.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
//   1. Loop forever repeating the following actions:
//   2. Get the latest game controller / joystick settings that have been received from the PC.
//   3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
//      simple action:
//      *  Joystick values are usually directly translated into power levels for a motor or
//         position of a servo.
//      *  Buttons are usually used to start/stop a motor or cause a servo to move to a specific
//         position.
//   4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
  initializeRobot();

  waitForStart();   // wait for start of tele-op phase

  while (true)
  {
    getJoystickSettings(joystick);
    movementControl();
    ballControl();
    lifterControl();
    GripperControl();
    basketControl();
  }
}
