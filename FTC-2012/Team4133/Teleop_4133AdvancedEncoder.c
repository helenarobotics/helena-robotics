#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,                    sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C2_1,     ballMotor,     tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     basketTurnMotor, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     leftLifterMotor, tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     rightLifterMotor, tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     leftMotor,     tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_2,     rightMotor,    tmotorNormal, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_2,    leftGripperServo,     tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    rightGripperServo,    tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    TleftGripperServo,    tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    TrightGripperServo,   tServoStandard)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

const int lifterMaxHeight = 1000;

int leftGripperPosition;
int rightGripperPosition;
int TleftGripperPosition;
int TrightGripperPosition;
int AllLeftGripperPosition;
int AllRightGripperPosition;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void initializeRobot()
{
  AllLeftGripperPosition  = ServoValue[leftGripperServo];
  AllRightGripperPosition = ServoValue[rightGripperServo];

  leftGripperPosition   = AllLeftGripperPosition;
  rightGripperPosition  = AllRightGripperPosition;
  TleftGripperPosition  = AllLeftGripperPosition;
  TrightGripperPosition = AllRightGripperPosition;

  servo[leftGripperServo]   = leftGripperPosition;
  servo[TleftGripperServo]  = TleftGripperPosition;
  servo[rightGripperServo]  = rightGripperPosition;
  servo[TrightGripperServo] = TrightGripperPosition;

  nMotorEncoder[rightLifterMotor] = 0;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                               Power
//
// Provides an exponential function for floating point numbers
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
float Power(float num, int exp)
{
    // require positive integer for the exponent
    if (exp <= 0)
        return 0;

    float result = num;
    for (int i = 1; i < exp; i++)
        result *= num;
    return result;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                               adjJoystickMotorPowerExp
//
// As the range of values for the joysticks are -128 to 127 and the range of power settings for the
// motors are -100 to 100. We must adjust the joystick values to be within the motor values using
// an exponential curve. This will allow the best control over our lifter.
//
// Also, since the joysticks do not always center exactly at position 0 when released, we use a
// thresh hold value to provide a small range of values that all equate to no movement
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
int adjJoystickMotorPowerExp(int i_joystickReading, float i_rangeMax, int i_threshHold)
{
  const float vSensitivity = 0.7;
  const int   vExp         = 3;

  int vMotorPower = i_joystickReading;

  //Compare to the thresh hold to account for variations in calibration
  if (abs(vMotorPower) < i_threshHold) {
    vMotorPower = 0;
  } else {
    //The value is outside the thresh hold. We now need to adjust to the
    //desired range. To do this first we convert the value to a floating
    //point number between -1 and 1
    float vFloatPower = vMotorPower / 127.0;

    //Next we apply our exponential formula
    float result = vSensitivity * Power(vFloatPower, vExp) +
                   (1 - vSensitivity) * vFloatPower;

    //Finally we adjust for our range
    vMotorPower = (int)(i_rangeMax * result);
  }

  return vMotorPower;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                               adjJoystickMotorPower
//
// As the range of values for the joysticks are -128 to 127 and the range of power settings for the
// motors are -100 to 100. We must adjust the joystick values to be within the motor values. This
// will allow the best driving experience for the robot.
//
// Also, since the joysticks do not always center exactly at position 0 when released, we use a
// thresh hold value to provide a small range of values that all equate to no movement
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
int adjJoystickMotorPower(int i_joystickReading, int i_rangeMax, int i_threshHold)
{
  int vMotorPower = i_joystickReading;

  //Compare to the thresh hold to account for variations in calibration
  if (abs(vMotorPower) < i_threshHold) {
    vMotorPower = 0;
  } else {
    //The value is outside the thresh hold. We now need to adjust to the
    //desired range. To do this first we need to subtract our thresh hold value
    vMotorPower = vMotorPower - i_threshHold;

    //Next we adjust for our range
    vMotorPower = floor((vMotorPower * i_rangeMax) / (127 - i_threshHold));
  }

  return vMotorPower;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Max
//
// This procedure returns the largest of two values
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
int max(int val1, int val2)
{
  if (val1 > val2)
    return val1;
  else
    return val2;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Min
//
// This procedure returns the smallest of two values
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
int min(int val1, int val2)
{
  if (val1 < val2)
    return val1;
  else
    return val2;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Movement Control
//
// This procedure is responsible for translating the joystick readings into motor power for the
// motors responsible for moving the robot
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void movementControl()
{
  int leftMotorPower;
  int rightMotorPower;
  int maxMotorPower;

  if (joy1Btn(5)) {
    maxMotorPower = 100;
  } else if (joy1Btn(7)) {
    maxMotorPower = 20;
  } else {
    maxMotorPower = 60;
  }

  leftMotorPower  = adjJoystickMotorPower(joystick.joy1_y1, maxMotorPower, 5);
  rightMotorPower = adjJoystickMotorPower(joystick.joy1_y2, maxMotorPower, 5);

  motor[rightMotor] = rightMotorPower;
  motor[leftMotor]  = leftMotorPower;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Ball Control
//
// This procedure is responsible for turning the motor on and off that controls the apparatus that
// picks up the racket balls off the floor of the field
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void ballControl()
{
  if (joy1Btn(6)) {
    motor[ballMotor] = 100;
  } else if (joy1Btn(8)) {
    motor[ballMotor] = -100;
  } else {
    motor[ballMotor] = 0;
  }
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Lifter Control
//
// This procedure is responsible for translating the joystick readings into motor power for the
// motors responsible for lifting and lowering the crate lifter apparatus
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void lifterControl()
{
  int   lifterPower;
  float lifterMaxPower = 100.0;

  /* if (joy2Btn(5)) {
    listerMaxPower = 75.0;
  } else if (joy2Btn(7)) {
    lifterMaxPower = 25.0;
  } else {
    lifterMaxPower = 50.0;
  } */

  lifterPower = adjJoystickMotorPowerExp(joystick.joy2_y1, lifterMaxPower, 5);

  /*if (lifterPower > 0 && nMotorEncoder[rightLifterMotor] >= lifterMaxHeight) {
    //Lifter is already at the top so stop the motor
    lifterPower = 0;
  } else if (lifterPower < 0 && nMotorEncoder[rightLifterMotor] <= 0) {
    //Lifter is already at the bottom so stop the motor
    lifterPower = 0;
  }*/

  motor[leftLifterMotor]  = lifterPower;
  motor[rightLifterMotor] = lifterPower;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Gripper Control
//
// This procedure is responsible for controlling the servos that move the gripper arms in and out
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void GripperControl()
{
  int vGripperInterval = 2;

  if (joy2Btn(5)) {
    if(joy2Btn(3)) {
      leftGripperPosition = ServoValue[leftGripperServo];
      servo[leftGripperServo] = leftGripperPosition + vGripperInterval;
    } else if (joy2Btn(4)) {
      TleftGripperPosition = ServoValue[TleftGripperServo];
      servo[TleftGripperServo] = TleftGripperPosition + vGripperInterval;
    } else {
      AllLeftGripperPosition = max(ServoValue[leftGripperServo],ServoValue[TleftGripperServo]);

      leftGripperPosition  = AllLeftGripperPosition;
      TleftGripperPosition = AllLeftGripperPosition;

      servo[leftGripperServo]  = AllLeftGripperPosition + vGripperInterval;
      servo[TleftGripperServo] = AllLeftGripperPosition + vGripperInterval;
    }
  } else if (joy2Btn(7)) {
    if (joy2Btn(3)) {
      leftGripperPosition = ServoValue[leftGripperServo];
      servo[leftGripperServo] = leftGripperPosition - vGripperInterval;
    } else if (joy2Btn(4)) {
      TleftGripperPosition = ServoValue[TleftGripperServo];
      servo[TleftGripperServo] = TleftGripperPosition - vGripperInterval;
    } else {
      AllLeftGripperPosition = min(ServoValue[leftGripperServo],ServoValue[TleftGripperServo]);

      leftGripperPosition  = AllLeftGripperPosition;
      TleftGripperPosition = AllLeftGripperPosition;

      servo[leftGripperServo]  = AllLeftGripperPosition - vGripperInterval;
      servo[TleftGripperServo] = AllLeftGripperPosition - vGripperInterval;
    }
  } else {
    servo[leftGripperServo]  = leftGripperPosition;
    servo[TleftGripperServo] = TleftGripperPosition;
  }

  if (joy2Btn(8)) {
    if (joy2Btn(3)) {
      rightGripperPosition = ServoValue[rightGripperServo];
      servo[rightGripperServo] = rightGripperPosition + vGripperInterval;
    } else if (joy2Btn(4)) {
      TrightGripperPosition = ServoValue[TrightGripperServo];
      servo[TrightGripperServo] = TrightGripperPosition + vGripperInterval;
    } else {
      AllRightGripperPosition = max(ServoValue[rightGripperServo],ServoValue[TrightGripperServo]);

      rightGripperPosition  = AllRightGripperPosition;
      TrightGripperPosition = AllRightGripperPosition;

      servo[rightGripperServo]  = AllRightGripperPosition + vGripperInterval;
      servo[TrightGripperServo] = AllRightGripperPosition + vGripperInterval;
    }
  } else if (joy2Btn(6)) {
    if (joy2Btn(3)) {
      rightGripperPosition = ServoValue[rightGripperServo];
      servo[rightGripperServo] = rightGripperPosition - vGripperInterval;
    } else if (joy2Btn(4)) {
      TrightGripperPosition = ServoValue[TrightGripperServo];
      servo[TrightGripperServo] = TrightGripperPosition - vGripperInterval;
    } else {
      AllRightGripperPosition = min(ServoValue[rightGripperServo],ServoValue[TrightGripperServo]);

      rightGripperPosition  = AllRightGripperPosition;
      TrightGripperPosition = AllRightGripperPosition;

      servo[rightGripperServo]  = AllRightGripperPosition - vGripperInterval;
      servo[TrightGripperServo] = AllRightGripperPosition - vGripperInterval;
    }
  } else {
    servo[rightGripperServo]  = rightGripperPosition;
    servo[TrightGripperServo] = TrightGripperPosition;
  }
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                      Basket Control
//
// This procedure is responsible for turning the motor on and off that controls the apparatus used
// to rotate baskets
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void basketControl()
{
  if (joy2Btn(1)) {
    motor[basketTurnMotor] = 15;
  } else if (joy2Btn(2)) {
    motor[basketTurnMotor] = -15;
  } else {
    motor[basketTurnMotor] = 0;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the tele-op robot operation.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
//   1. Loop forever repeating the following actions:
//   2. Get the latest game controller / joystick settings that have been received from the PC.
//   3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
//      simple action:
//      *  Joystick values are usually directly translated into power levels for a motor or
//         position of a servo.
//      *  Buttons are usually used to start/stop a motor or cause a servo to move to a specific
//         position.
//   4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
  initializeRobot();

  waitForStart();   // wait for start of tele-op phase

  while (true) {
    getJoystickSettings(joystick);
    movementControl();
    ballControl();
    lifterControl();
    GripperControl();
    basketControl();
  }
}
