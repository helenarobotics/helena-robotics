#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     irSeeker,            sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     gyro,                sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,          ,              tmotorNormal, openLoop)
#pragma config(Motor,  motorB,          ,              tmotorNormal, openLoop)
#pragma config(Motor,  motorC,          ,              tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     ballMotor,     tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     basketTurnMotor, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     leftLifterMotor, tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     rightLifterMotor, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     DriveRight,    tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     DriveLeft,     tmotorNormal, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C1_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_2,    leftGripperServo,     tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    rightGripperServo,    tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    TleftGripperServo,    tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    TrightGripperServo,   tServoStandard)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  // Include file to "handle" the Bluetooth messages.
#include "drivers/HTGyro-driver.h"

const int vtile = 2750; // based off of 4 in. diameter wheel
//const int  v90turn        = 1178;
//const int  v45turn        = 589;
const int vThreshHold = 5;
const long vSyncInterval = 250;
const long vSyncTickError = 50;

typedef enum {
    FORWARD,
    BACKWARD,
    LEFT,
    RIGHT,
} cmdState;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
    // Place code here to initialize servos to starting positions.
    // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

    return;
}

void move(int speed, int vdistance, cmdState cmd)
{
    int vPrevLeftPos = 0;
    int vPrevRightPos = 0;
    int vCurrLeftPos = 0;
    int vCurrRightPos = 0;
    int vLeftPower = speed;
    int vRightPower = speed;
    int vRightOffset = 1;
    int vLeftOffset = 1;
    long vNxtSyncTime = nPgmTime + vSyncInterval;

    //Set our motor offsets based on the supplied command
    switch (cmd)
    {
    case FORWARD:
        //To move forward both motor powers should be positive
        vRightOffset = 1;
        vLeftOffset = 1;
        break;
    case BACKWARD:
        //To move backward both motor powers should be negative
        vRightOffset = -1;
        vLeftOffset = -1;
        break;
    case LEFT:
        //To turn left, the left motor must run backward and the right motor forward
        vRightOffset = 1;
        vLeftOffset = -1;
        break;
    case RIGHT:
        //To turn right, the right motor must run backward and the left motor forward
        vRightOffset = -1;
        vLeftOffset = 1;
        break;
    }

    //Reset our encoders prior to movement
    nMotorEncoder[DriveLeft] = 0;
    nMotorEncoder[DriveRight] = 0;

    //Start up the motors
    motor[DriveLeft] = vLeftPower * vLeftOffset;
    motor[DriveRight] = vRightPower * vRightOffset;

    //Loop until both motors have traveled the required distance
    while (abs(nMotorEncoder[DriveLeft]) < vdistance || abs(nMotorEncoder[DriveRight]) < vdistance)
    {
        //Determine the current value of the encoders
        vCurrLeftPos = abs(nMotorEncoder[DriveLeft]);
        vCurrRightPos = abs(nMotorEncoder[DriveRight]);

        //We only perform error correction at specific intervals
        if (nPgmTime >= vNxtSyncTime)
        {
            //See if we are far enough 'out of sync' to warrant speed corrections
            //To do this, we average the encoder values and then compare each individual motor to that average
            int avg = (vCurrLeftPos + vCurrRightPos) / 2;
            if (abs(vCurrLeftPos - avg) > vSyncTickError || abs(vCurrRightPos - avg) > vSyncTickError)
            {
                //We are out of sync. Determine which side is falling behind the other and adjust the speed
                //We default to slowing down the motors. The only time we speed up a motoro is if it was
                //previously slowed
                if (vCurrLeftPos < vCurrRightPos)
                {
                    if (vLeftPower < speed)
                    {
                        vLeftPower = vLeftPower + 1;
                        motor[DriveLeft] = vLeftPower * vLeftOffset;
                    }
                    else
                    {
                        vRightPower = vRightPower - 1;
                        motor[DriveRight] = vRightPower * vRightOffset;
                    }
                }
                else
                {
                    if (vRightPower < speed)
                    {
                        vRightPower = vRightPower + 1;
                        motor[DriveRight] = vRightPower * vRightOffset;
                    }
                    else
                    {
                        vLeftPower = vLeftPower - 1;
                        motor[DriveLeft] = vLeftPower * vLeftOffset;
                    }
                }
            }

            //Now we check to ensure we have not run into an object preventing us from moving.
            if ((vCurrLeftPos <= (vPrevLeftPos + vThreshHold)) || (vCurrRightPos <= (vPrevRightPos + vThreshHold)))
            {
                //At least one motor is stuck. Turn off motors and wait for a period of time to avoid motor burn out.
                motor[DriveLeft] = 0;
                motor[DriveRight] = 0;

                wait1Msec(1000);

                motor[DriveLeft] = vLeftPower * vLeftOffset;
                motor[DriveRight] = vRightPower * vRightOffset;
            }

            vNxtSyncTime = nPgmTime + vSyncInterval;

            vPrevLeftPos = vCurrLeftPos;
            vPrevRightPos = vCurrRightPos;
        }
    }

    motor[DriveLeft] = 0;
    motor[DriveRight] = 0;

    //The following line is used to pause the robot in between movements
    wait1Msec(100);
}

void GyroTurn(int vspeed, int vdegrees, cmdState cmd)
{
    float vcurrposition = 0;
    int vprevtime = nPgmTime;
    int vcurrtime;
    int vcurrRate;
    int voffset;
    float deltaSecs;
    float degChange;

    if (cmd == LEFT)
    {
        motor[DriveLeft] = -1 * vspeed;
        motor[DriveRight] = vspeed;
        voffset = -1;
    }
    else
    {
        motor[DriveLeft] = vspeed;
        motor[DriveRight] = -1 * vspeed;
        voffset = 1;
    }

    while (vcurrposition < vdegrees)
    {
        // This tells us the current rate of rotation in degrees per
        // second.
        vcurrRate = HTGYROreadRot(gyro) * voffset;

        // How much time has elapsed since we last checked, which we use
        // to determine how far we've turned
        vcurrtime = nPgmTime;

        deltaSecs = (vcurrtime - vprevtime) / 1000.0;
        if (deltaSecs < 0)
        {
            deltaSecs = ((vcurrtime + 1024) - (vprevtime + 1024)) / 1000.0;
        }

        // Calculate how many degrees the heading changed.
        degChange = (float)vcurrRate * deltaSecs;
        vcurrposition = vcurrposition + degChange;

        vprevtime = vcurrtime;
    }

    motor[DriveLeft] = 0;
    motor[DriveRight] = 0;

    //The following line is used to pause the robot in between movements
    wait1Msec(100);
}

void findBeacon()
{
    int speed = 50;
    int vEncoderVal;

    //First we must turn the robot until the beacon is in front of us
    while (SensorValue[irSeeker] < 5)
    {
        motor[DriveLeft] = speed;
        motor[DriveRight] = speed * (-1);
    }

    while (SensorValue[irSeeker] > 5)
    {
        motor[DriveLeft] = speed * (-1);
        motor[DriveRight] = speed;
    }

    //beacon should now be in front of us. As the IR sensor has a wide range for what it considers to be in front of us
    //we need to sweep the robot first left then right to find the full range of where the beacon is
    while (SensorValue[irSeeker] >= 5)
    {
        motor[DriveLeft] = speed * (-1);
        motor[DriveRight] = speed;
    }

    motor[DriveLeft] = 0;
    motor[DriveRight] = 0;


    //Reset the motor encoder at this position to note our furthest point to the left
    nMotorEncoder[DriveLeft] = 0;

    while (SensorValue[irSeeker] <= 5)
    {
        motor[DriveLeft] = speed;
        motor[DriveRight] = speed * (-1);
    }

    motor[DriveLeft] = 0;
    motor[DriveRight] = 0;

    vEncoderVal = nMotorEncoder[DriveLeft];

    //Now that we know the range, the beacon should be in the exact middle of the range.
    vEncoderVal = (vEncoderVal + 200) / 2;

    //Turn to the middle of the range
    while (nMotorEncoder[DriveLeft] > vEncoderVal)
    {
        motor[DriveLeft] = speed * (-1);
        motor[DriveRight] = speed;
    }

    //The beacon should now be directly in front of us. Stop the motors
    motor[DriveLeft] = 0;
    motor[DriveRight] = 0;
}

void parkballfront(string vcolor, string vposition)
{
    int vpostile = 1;

    if (vposition == "in")
    {
        vpostile = vpostile + 1;
    }

    //Start by moving down off the home zone
    move(50, 4100, FORWARD);

    //Next turn in toward the center of the field
    if (vcolor == "red")
    {
        GyroTurn(50, 90, LEFT);
    }
    else
    {
        GyroTurn(50, 90, RIGHT);
    }

    //Move forward again to position robot by bowling ball
    move(50, vtile * vpostile, FORWARD);

    //Turn toward the front parking zone
    /*if (vcolor == "red")
      {
      GyroTurn (50, 45, LEFT);
      }
      else
      {
      GyroTurn (50, 45, RIGHT);
      }*/

    findBeacon();

    //Move forward into parking zone
    move(50, vtile * 3, FORWARD);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
    initializeRobot();

    waitForStart(); // Wait for the beginning of autonomous phase.

    ///////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////
    ////                                                   ////
    ////    Add your robot specific autonomous code here.  ////
    ////                                                   ////
    ///////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////

    ////////////////////////////////
    // Testing                    //
    ////////////////////////////////
    //moveforward (50,4000);
    //wait1Msec(5000);
    //moveforward (50,vtile);
    //leftturn(50,v90turn);

    //////////////////////////////////
    //park with ball front          //
    //////////////////////////////////
    //parkballfront ("red", "out");
    findBeacon();
}
